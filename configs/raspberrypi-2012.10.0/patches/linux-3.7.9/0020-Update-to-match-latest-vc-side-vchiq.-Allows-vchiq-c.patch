From ce0023a8b5d8deab6229e877d88cc7ee837afae4 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 26 Mar 2012 22:10:01 +0100
Subject: [PATCH 020/195] Update to match latest vc side vchiq. Allows vchiq calls from kernel.

---
 drivers/misc/vc04_services/Makefile                |    4 +-
 .../interface/vchi/connections/connection.h        |  309 ++++++++++
 .../interface/vchi/message_drivers/message.h       |  186 ++++++
 drivers/misc/vc04_services/interface/vchi/vchi.h   |  347 +++++++++++
 .../misc/vc04_services/interface/vchi/vchi_cfg.h   |  214 +++++++
 .../interface/vchi/vchi_cfg_internal.h             |   56 ++
 .../vc04_services/interface/vchi/vchi_common.h     |  152 +++++
 .../interface/vchiq_arm/vchiq_2835_arm.c           |   73 ++-
 .../vc04_services/interface/vchiq_arm/vchiq_arm.c  |  618 +++++++++++++++++++-
 .../vc04_services/interface/vchiq_arm/vchiq_arm.h  |   80 +++
 .../vc04_services/interface/vchiq_arm/vchiq_core.c |  216 +++++--
 .../vc04_services/interface/vchiq_arm/vchiq_core.h |   59 ++-
 .../vc04_services/interface/vchiq_arm/vchiq_if.h   |   19 +-
 .../vc04_services/interface/vchiq_arm/vchiq_lib.c  |  118 ++++-
 .../vc04_services/interface/vchiq_arm/vchiq_shim.c |   37 ++-
 15 files changed, 2370 insertions(+), 118 deletions(-)
 create mode 100644 drivers/misc/vc04_services/interface/vchi/connections/connection.h
 create mode 100644 drivers/misc/vc04_services/interface/vchi/message_drivers/message.h
 create mode 100644 drivers/misc/vc04_services/interface/vchi/vchi.h
 create mode 100644 drivers/misc/vc04_services/interface/vchi/vchi_cfg.h
 create mode 100644 drivers/misc/vc04_services/interface/vchi/vchi_cfg_internal.h
 create mode 100644 drivers/misc/vc04_services/interface/vchi/vchi_common.h

diff --git a/drivers/misc/vc04_services/Makefile b/drivers/misc/vc04_services/Makefile
index d26ece7..ee53af7 100644
--- a/drivers/misc/vc04_services/Makefile
+++ b/drivers/misc/vc04_services/Makefile
@@ -2,6 +2,8 @@ obj-$(CONFIG_BCM2708_VCHIQ)	+= vchiq.o
 
 vchiq-objs := \
    interface/vchiq_arm/vchiq_core.o  \
+   interface/vchiq_arm/vchiq_shim.o  \
+   interface/vchiq_arm/vchiq_util.o  \
    interface/vchiq_arm/vchiq_arm.o \
    interface/vchiq_arm/vchiq_kern_lib.o \
    interface/vchiq_arm/vchiq_2835_arm.o \
@@ -13,7 +15,7 @@ vchiq-objs := \
    interface/vcos/generic/vcos_mem_from_malloc.o \
    interface/vcos/generic/vcos_cmd.o
 
-EXTRA_CFLAGS += -DVCOS_VERIFY_BKPTS=1 -Idrivers/misc/vc04_services -Idrivers/misc/vc04_services/interface/vcos/linuxkernel
+EXTRA_CFLAGS += -DVCOS_VERIFY_BKPTS=1 -DUSE_VCHIQ_ARM -D__VCCOREVER__=0x04000000 -Idrivers/misc/vc04_services -Idrivers/misc/vc04_services/interface/vcos/linuxkernel
 
 
 
diff --git a/drivers/misc/vc04_services/interface/vchi/connections/connection.h b/drivers/misc/vc04_services/interface/vchi/connections/connection.h
new file mode 100644
index 0000000..2fe5742
--- /dev/null
+++ b/drivers/misc/vc04_services/interface/vchi/connections/connection.h
@@ -0,0 +1,309 @@
+/*
+ * Copyright (c) 2010-2011 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CONNECTION_H_
+#define CONNECTION_H_
+
+#include "interface/vchi/vchi_cfg_internal.h"
+#include "interface/vchi/vchi_common.h"
+#include "interface/vchi/message_drivers/message.h"
+
+/******************************************************************************
+ Global defs
+ *****************************************************************************/
+
+// Opaque handle for a connection / service pair
+typedef struct opaque_vchi_connection_connected_service_handle_t *VCHI_CONNECTION_SERVICE_HANDLE_T;
+
+// opaque handle to the connection state information
+typedef struct opaque_vchi_connection_info_t VCHI_CONNECTION_STATE_T;
+
+typedef struct vchi_connection_t VCHI_CONNECTION_T;
+
+
+/******************************************************************************
+ API
+ *****************************************************************************/
+
+// Routine to init a connection with a particular low level driver
+typedef VCHI_CONNECTION_STATE_T * (*VCHI_CONNECTION_INIT_T)( struct vchi_connection_t * connection,
+                                                             const VCHI_MESSAGE_DRIVER_T * driver );
+
+// Routine to control CRC enabling at a connection level
+typedef int32_t (*VCHI_CONNECTION_CRC_CONTROL_T)( VCHI_CONNECTION_STATE_T *state_handle,
+                                                  VCHI_CRC_CONTROL_T control );
+
+// Routine to create a service
+typedef int32_t (*VCHI_CONNECTION_SERVICE_CONNECT_T)( VCHI_CONNECTION_STATE_T *state_handle,
+                                                      vcos_fourcc_t service_id,
+                                                      uint32_t rx_fifo_size,
+                                                      uint32_t tx_fifo_size,
+                                                      int server,
+                                                      VCHI_CALLBACK_T callback,
+                                                      void *callback_param,
+                                                      vcos_bool_t want_crc,
+                                                      vcos_bool_t want_unaligned_bulk_rx,
+                                                      vcos_bool_t want_unaligned_bulk_tx,
+                                                      VCHI_CONNECTION_SERVICE_HANDLE_T *service_handle );
+
+// Routine to close a service
+typedef int32_t (*VCHI_CONNECTION_SERVICE_DISCONNECT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle );
+
+// Routine to queue a message
+typedef int32_t (*VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                            const void *data,
+                                                            uint32_t data_size,
+                                                            VCHI_FLAGS_T flags,
+                                                            void *msg_handle );
+
+// scatter-gather (vector) message queueing
+typedef int32_t (*VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                             VCHI_MSG_VECTOR_T *vector,
+                                                             uint32_t count,
+                                                             VCHI_FLAGS_T flags,
+                                                             void *msg_handle );
+
+// Routine to dequeue a message
+typedef int32_t (*VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                              void *data,
+                                                              uint32_t max_data_size_to_read,
+                                                              uint32_t *actual_msg_size,
+                                                              VCHI_FLAGS_T flags );
+
+// Routine to peek at a message
+typedef int32_t (*VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                           void **data,
+                                                           uint32_t *msg_size,
+                                                           VCHI_FLAGS_T flags );
+
+// Routine to hold a message
+typedef int32_t (*VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                           void **data,
+                                                           uint32_t *msg_size,
+                                                           VCHI_FLAGS_T flags,
+                                                           void **message_handle );
+
+// Routine to initialise a received message iterator
+typedef int32_t (*VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                                VCHI_MSG_ITER_T *iter,
+                                                                VCHI_FLAGS_T flags );
+
+// Routine to release a held message
+typedef int32_t (*VCHI_CONNECTION_HELD_MSG_RELEASE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                       void *message_handle );
+
+// Routine to get info on a held message
+typedef int32_t (*VCHI_CONNECTION_HELD_MSG_INFO_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                    void *message_handle,
+                                                    void **data,
+                                                    int32_t *msg_size,
+                                                    uint32_t *tx_timestamp,
+                                                    uint32_t *rx_timestamp );
+
+// Routine to check whether the iterator has a next message
+typedef vcos_bool_t (*VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
+                                                       const VCHI_MSG_ITER_T *iter );
+
+// Routine to advance the iterator
+typedef int32_t (*VCHI_CONNECTION_MSG_ITER_NEXT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
+                                                    VCHI_MSG_ITER_T *iter,
+                                                    void **data,
+                                                    uint32_t *msg_size );
+
+// Routine to remove the last message returned by the iterator
+typedef int32_t (*VCHI_CONNECTION_MSG_ITER_REMOVE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
+                                                      VCHI_MSG_ITER_T *iter );
+
+// Routine to hold the last message returned by the iterator
+typedef int32_t (*VCHI_CONNECTION_MSG_ITER_HOLD_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
+                                                    VCHI_MSG_ITER_T *iter,
+                                                    void **msg_handle );
+
+// Routine to transmit bulk data
+typedef int32_t (*VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                          const void *data_src,
+                                                          uint32_t data_size,
+                                                          VCHI_FLAGS_T flags,
+                                                          void *bulk_handle );
+
+// Routine to receive data
+typedef int32_t (*VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
+                                                         void *data_dst,
+                                                         uint32_t data_size,
+                                                         VCHI_FLAGS_T flags,
+                                                         void *bulk_handle );
+
+// Routine to report if a server is available
+typedef int32_t (*VCHI_CONNECTION_SERVER_PRESENT)( VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, int32_t peer_flags );
+
+// Routine to report the number of RX slots available
+typedef int (*VCHI_CONNECTION_RX_SLOTS_AVAILABLE)( const VCHI_CONNECTION_STATE_T *state );
+
+// Routine to report the RX slot size
+typedef uint32_t (*VCHI_CONNECTION_RX_SLOT_SIZE)( const VCHI_CONNECTION_STATE_T *state );
+
+// Callback to indicate that the other side has added a buffer to the rx bulk DMA FIFO
+typedef void (*VCHI_CONNECTION_RX_BULK_BUFFER_ADDED)(VCHI_CONNECTION_STATE_T *state,
+                                                     vcos_fourcc_t service,
+                                                     uint32_t length,
+                                                     MESSAGE_TX_CHANNEL_T channel,
+                                                     uint32_t channel_params,
+                                                     uint32_t data_length,
+                                                     uint32_t data_offset);
+
+// Callback to inform a service that a Xon or Xoff message has been received
+typedef void (*VCHI_CONNECTION_FLOW_CONTROL)(VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, int32_t xoff);
+
+// Callback to inform a service that a server available reply message has been received
+typedef void (*VCHI_CONNECTION_SERVER_AVAILABLE_REPLY)(VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, uint32_t flags);
+
+// Callback to indicate that bulk auxiliary messages have arrived
+typedef void (*VCHI_CONNECTION_BULK_AUX_RECEIVED)(VCHI_CONNECTION_STATE_T *state);
+
+// Callback to indicate that bulk auxiliary messages have arrived
+typedef void (*VCHI_CONNECTION_BULK_AUX_TRANSMITTED)(VCHI_CONNECTION_STATE_T *state, void *handle);
+
+// Callback with all the connection info you require
+typedef void (*VCHI_CONNECTION_INFO)(VCHI_CONNECTION_STATE_T *state, uint32_t protocol_version, uint32_t slot_size, uint32_t num_slots, uint32_t min_bulk_size);
+
+// Callback to inform of a disconnect
+typedef void (*VCHI_CONNECTION_DISCONNECT)(VCHI_CONNECTION_STATE_T *state, uint32_t flags);
+
+// Callback to inform of a power control request
+typedef void (*VCHI_CONNECTION_POWER_CONTROL)(VCHI_CONNECTION_STATE_T *state, MESSAGE_TX_CHANNEL_T channel, vcos_bool_t enable);
+
+// allocate memory suitably aligned for this connection
+typedef void * (*VCHI_BUFFER_ALLOCATE)(VCHI_CONNECTION_SERVICE_HANDLE_T service_handle, uint32_t * length);
+
+// free memory allocated by buffer_allocate
+typedef void   (*VCHI_BUFFER_FREE)(VCHI_CONNECTION_SERVICE_HANDLE_T service_handle, void * address);
+
+
+/******************************************************************************
+ System driver struct
+ *****************************************************************************/
+
+struct opaque_vchi_connection_api_t
+{
+   // Routine to init the connection
+   VCHI_CONNECTION_INIT_T                      init;
+
+   // Connection-level CRC control
+   VCHI_CONNECTION_CRC_CONTROL_T               crc_control;
+
+   // Routine to connect to or create service
+   VCHI_CONNECTION_SERVICE_CONNECT_T           service_connect;
+
+   // Routine to disconnect from a service
+   VCHI_CONNECTION_SERVICE_DISCONNECT_T        service_disconnect;
+
+   // Routine to queue a message
+   VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T     service_queue_msg;
+
+   // scatter-gather (vector) message queue
+   VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T    service_queue_msgv;
+
+   // Routine to dequeue a message
+   VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T   service_dequeue_msg;
+
+   // Routine to peek at a message
+   VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T      service_peek_msg;
+
+   // Routine to hold a message
+   VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T      service_hold_msg;
+
+   // Routine to initialise a received message iterator
+   VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T service_look_ahead_msg;
+
+   // Routine to release a message
+   VCHI_CONNECTION_HELD_MSG_RELEASE_T          held_msg_release;
+
+   // Routine to get information on a held message
+   VCHI_CONNECTION_HELD_MSG_INFO_T             held_msg_info;
+
+   // Routine to check for next message on iterator
+   VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T         msg_iter_has_next;
+
+   // Routine to get next message on iterator
+   VCHI_CONNECTION_MSG_ITER_NEXT_T             msg_iter_next;
+
+   // Routine to remove the last message returned by iterator
+   VCHI_CONNECTION_MSG_ITER_REMOVE_T           msg_iter_remove;
+
+   // Routine to hold the last message returned by iterator
+   VCHI_CONNECTION_MSG_ITER_HOLD_T             msg_iter_hold;
+
+   // Routine to transmit bulk data
+   VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T       bulk_queue_transmit;
+
+   // Routine to receive data
+   VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T        bulk_queue_receive;
+
+   // Routine to report the available servers
+   VCHI_CONNECTION_SERVER_PRESENT              server_present;
+
+   // Routine to report the number of RX slots available
+   VCHI_CONNECTION_RX_SLOTS_AVAILABLE          connection_rx_slots_available;
+
+   // Routine to report the RX slot size
+   VCHI_CONNECTION_RX_SLOT_SIZE                connection_rx_slot_size;
+
+   // Callback to indicate that the other side has added a buffer to the rx bulk DMA FIFO
+   VCHI_CONNECTION_RX_BULK_BUFFER_ADDED        rx_bulk_buffer_added;
+
+   // Callback to inform a service that a Xon or Xoff message has been received
+   VCHI_CONNECTION_FLOW_CONTROL                flow_control;
+
+   // Callback to inform a service that a server available reply message has been received
+   VCHI_CONNECTION_SERVER_AVAILABLE_REPLY      server_available_reply;
+
+   // Callback to indicate that bulk auxiliary messages have arrived
+   VCHI_CONNECTION_BULK_AUX_RECEIVED           bulk_aux_received;
+
+   // Callback to indicate that a bulk auxiliary message has been transmitted
+   VCHI_CONNECTION_BULK_AUX_TRANSMITTED        bulk_aux_transmitted;
+
+   // Callback to provide information about the connection
+   VCHI_CONNECTION_INFO                        connection_info;
+
+   // Callback to notify that peer has requested disconnect
+   VCHI_CONNECTION_DISCONNECT                  disconnect;
+
+   // Callback to notify that peer has requested power change
+   VCHI_CONNECTION_POWER_CONTROL               power_control;
+
+   // allocate memory suitably aligned for this connection
+   VCHI_BUFFER_ALLOCATE                        buffer_allocate;
+
+   // free memory allocated by buffer_allocate
+   VCHI_BUFFER_FREE                            buffer_free;
+
+};
+
+struct vchi_connection_t {
+   const VCHI_CONNECTION_API_T *api;
+   VCHI_CONNECTION_STATE_T     *state;
+#ifdef VCHI_COARSE_LOCKING
+   VCOS_SEMAPHORE_T             sem;
+#endif
+};
+
+
+#endif /* CONNECTION_H_ */
+
+/****************************** End of file **********************************/
diff --git a/drivers/misc/vc04_services/interface/vchi/message_drivers/message.h b/drivers/misc/vc04_services/interface/vchi/message_drivers/message.h
new file mode 100644
index 0000000..7701b15
--- /dev/null
+++ b/drivers/misc/vc04_services/interface/vchi/message_drivers/message.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2010-2011 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _VCHI_MESSAGE_H_
+#define _VCHI_MESSAGE_H_
+
+#include "interface/vchi/vchi_cfg_internal.h"
+#include "interface/vcos/vcos.h"
+#include "interface/vchi/vchi_common.h"
+
+
+typedef enum message_event_type {
+   MESSAGE_EVENT_NONE,
+   MESSAGE_EVENT_NOP,
+   MESSAGE_EVENT_MESSAGE,
+   MESSAGE_EVENT_SLOT_COMPLETE,
+   MESSAGE_EVENT_RX_BULK_PAUSED,
+   MESSAGE_EVENT_RX_BULK_COMPLETE,
+   MESSAGE_EVENT_TX_COMPLETE,
+   MESSAGE_EVENT_MSG_DISCARDED
+} MESSAGE_EVENT_TYPE_T;
+
+typedef enum vchi_msg_flags
+{
+   VCHI_MSG_FLAGS_NONE                  = 0x0,
+   VCHI_MSG_FLAGS_TERMINATE_DMA         = 0x1
+} VCHI_MSG_FLAGS_T;
+
+typedef enum message_tx_channel
+{
+   MESSAGE_TX_CHANNEL_MESSAGE           = 0,
+   MESSAGE_TX_CHANNEL_BULK              = 1 // drivers may provide multiple bulk channels, from 1 upwards
+} MESSAGE_TX_CHANNEL_T;
+
+// Macros used for cycling through bulk channels
+#define MESSAGE_TX_CHANNEL_BULK_PREV(c) (MESSAGE_TX_CHANNEL_BULK+((c)-MESSAGE_TX_CHANNEL_BULK+VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION-1)%VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION)
+#define MESSAGE_TX_CHANNEL_BULK_NEXT(c) (MESSAGE_TX_CHANNEL_BULK+((c)-MESSAGE_TX_CHANNEL_BULK+1)%VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION)
+
+typedef enum message_rx_channel
+{
+   MESSAGE_RX_CHANNEL_MESSAGE           = 0,
+   MESSAGE_RX_CHANNEL_BULK              = 1 // drivers may provide multiple bulk channels, from 1 upwards
+} MESSAGE_RX_CHANNEL_T;
+
+// Message receive slot information
+typedef struct rx_msg_slot_info {
+
+   struct rx_msg_slot_info *next;
+   //struct slot_info *prev;
+#if !defined VCHI_COARSE_LOCKING
+   VCOS_SEMAPHORE_T   sem;
+#endif
+
+   uint8_t           *addr;               // base address of slot
+   uint32_t           len;                // length of slot in bytes
+
+   uint32_t           write_ptr;          // hardware causes this to advance
+   uint32_t           read_ptr;           // this module does the reading
+   int                active;             // is this slot in the hardware dma fifo?
+   uint32_t           msgs_parsed;        // count how many messages are in this slot
+   uint32_t           msgs_released;      // how many messages have been released
+   void              *state;              // connection state information
+   uint8_t            ref_count[VCHI_MAX_SERVICES_PER_CONNECTION];          // reference count for slots held by services
+} RX_MSG_SLOTINFO_T;
+
+// The message driver no longer needs to know about the fields of RX_BULK_SLOTINFO_T - sort this out.
+// In particular, it mustn't use addr and len - they're the client buffer, but the message
+// driver will be tasked with sending the aligned core section.
+typedef struct rx_bulk_slotinfo_t {
+   struct rx_bulk_slotinfo_t *next;
+
+   VCOS_SEMAPHORE_T *blocking;
+
+   // needed by DMA
+   void        *addr;
+   uint32_t     len;
+
+   // needed for the callback
+   void        *service;
+   void        *handle;
+   VCHI_FLAGS_T flags;
+} RX_BULK_SLOTINFO_T;
+
+
+/* ----------------------------------------------------------------------
+ * each connection driver will have a pool of the following struct.
+ *
+ * the pool will be managed by vchi_qman_*
+ * this means there will be multiple queues (single linked lists)
+ * a given struct message_info will be on exactly one of these queues
+ * at any one time
+ * -------------------------------------------------------------------- */
+typedef struct rx_message_info {
+
+   struct message_info *next;
+   //struct message_info *prev;
+
+   uint8_t    *addr;
+   uint32_t   len;
+   RX_MSG_SLOTINFO_T *slot; // points to whichever slot contains this message
+   uint32_t   tx_timestamp;
+   uint32_t   rx_timestamp;
+
+} RX_MESSAGE_INFO_T;
+
+typedef struct {
+   MESSAGE_EVENT_TYPE_T type;
+
+   struct {
+      // for messages
+      void    *addr;           // address of message
+      uint16_t slot_delta;     // whether this message indicated slot delta
+      uint32_t len;            // length of message
+      RX_MSG_SLOTINFO_T *slot; // slot this message is in
+      vcos_fourcc_t service;   // service id this message is destined for
+      uint32_t tx_timestamp;   // timestamp from the header
+      uint32_t rx_timestamp;   // timestamp when we parsed it
+   } message;
+
+   // FIXME: cleanup slot reporting...
+   RX_MSG_SLOTINFO_T *rx_msg;
+   RX_BULK_SLOTINFO_T *rx_bulk;
+   void *tx_handle;
+   MESSAGE_TX_CHANNEL_T tx_channel;
+
+} MESSAGE_EVENT_T;
+
+
+// callbacks
+typedef void VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T( void *state );
+
+typedef struct {
+   VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T *event_callback;
+} VCHI_MESSAGE_DRIVER_OPEN_T;
+
+
+// handle to this instance of message driver (as returned by ->open)
+typedef struct opaque_mhandle_t *VCHI_MDRIVER_HANDLE_T;
+
+struct opaque_vchi_message_driver_t {
+   VCHI_MDRIVER_HANDLE_T *(*open)( VCHI_MESSAGE_DRIVER_OPEN_T *params, void *state );
+   int32_t (*suspending)( VCHI_MDRIVER_HANDLE_T *handle );
+   int32_t (*resumed)( VCHI_MDRIVER_HANDLE_T *handle );
+   int32_t (*power_control)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T, vcos_bool_t enable );
+   int32_t (*add_msg_rx_slot)( VCHI_MDRIVER_HANDLE_T *handle, RX_MSG_SLOTINFO_T *slot );      // rx message
+   int32_t (*add_bulk_rx)( VCHI_MDRIVER_HANDLE_T *handle, void *data, uint32_t len, RX_BULK_SLOTINFO_T *slot );  // rx data (bulk)
+   int32_t (*send)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel, const void *data, uint32_t len, VCHI_MSG_FLAGS_T flags, void *send_handle );      // tx (message & bulk)
+   void    (*next_event)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_EVENT_T *event );     // get the next event from message_driver
+   int32_t (*enable)( VCHI_MDRIVER_HANDLE_T *handle );
+   int32_t (*form_message)( VCHI_MDRIVER_HANDLE_T *handle, vcos_fourcc_t service_id, VCHI_MSG_VECTOR_T *vector, uint32_t count, void
+                            *address, uint32_t length_avail, uint32_t max_total_length, vcos_bool_t pad_to_fill, vcos_bool_t allow_partial );
+
+   int32_t (*update_message)( VCHI_MDRIVER_HANDLE_T *handle, void *dest, int16_t *slot_count );
+   int32_t (*buffer_aligned)( VCHI_MDRIVER_HANDLE_T *handle, int tx, int uncached, const void *address, const uint32_t length );
+   void *  (*allocate_buffer)( VCHI_MDRIVER_HANDLE_T *handle, uint32_t *length );
+   void    (*free_buffer)( VCHI_MDRIVER_HANDLE_T *handle, void *address );
+   int     (*rx_slot_size)( VCHI_MDRIVER_HANDLE_T *handle, int msg_size );
+   int     (*tx_slot_size)( VCHI_MDRIVER_HANDLE_T *handle, int msg_size );
+
+   vcos_bool_t  (*tx_supports_terminate)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
+   uint32_t (*tx_bulk_chunk_size)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
+   int     (*tx_alignment)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
+   int     (*rx_alignment)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_RX_CHANNEL_T channel );
+   void    (*form_bulk_aux)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel, const void *data, uint32_t len, uint32_t chunk_size, const void **aux_data, int32_t *aux_len );
+   void    (*debug)( VCHI_MDRIVER_HANDLE_T *handle );
+};
+
+
+#endif // _VCHI_MESSAGE_H_
+
+/****************************** End of file ***********************************/
diff --git a/drivers/misc/vc04_services/interface/vchi/vchi.h b/drivers/misc/vc04_services/interface/vchi/vchi.h
new file mode 100644
index 0000000..e441d8c
--- /dev/null
+++ b/drivers/misc/vc04_services/interface/vchi/vchi.h
@@ -0,0 +1,347 @@
+/*
+ * Copyright (c) 2010-2011 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*=============================================================================
+Contains the protypes for the vchi functions.
+=============================================================================*/
+
+#ifndef VCHI_H_
+#define VCHI_H_
+
+#include "interface/vcos/vcos.h"
+#include "interface/vchi/vchi_cfg.h"
+#include "interface/vchi/vchi_common.h"
+#include "interface/vchi/connections/connection.h"
+#include "vchi_mh.h"
+
+
+/******************************************************************************
+ Global defs
+ *****************************************************************************/
+
+#define VCHI_BULK_ROUND_UP(x)     ((((unsigned long)(x))+VCHI_BULK_ALIGN-1) & ~(VCHI_BULK_ALIGN-1))
+#define VCHI_BULK_ROUND_DOWN(x)   (((unsigned long)(x)) & ~(VCHI_BULK_ALIGN-1))
+#define VCHI_BULK_ALIGN_NBYTES(x) (VCHI_BULK_ALIGNED(x) ? 0 : (VCHI_BULK_ALIGN - ((unsigned long)(x) & (VCHI_BULK_ALIGN-1))))
+
+#ifdef USE_VCHIQ_ARM
+#define VCHI_BULK_ALIGNED(x)      1
+#else
+#define VCHI_BULK_ALIGNED(x)      (((unsigned long)(x) & (VCHI_BULK_ALIGN-1)) == 0)
+#endif
+
+
+typedef enum
+{
+   VCHI_VEC_POINTER,
+   VCHI_VEC_HANDLE,
+   VCHI_VEC_LIST
+} VCHI_MSG_VECTOR_TYPE_T;
+
+typedef struct vchi_msg_vector_ex {
+
+   VCHI_MSG_VECTOR_TYPE_T type;
+   union
+   {
+      // a memory handle
+      struct
+      {
+         VCHI_MEM_HANDLE_T handle;
+         uint32_t offset;
+         int32_t vec_len;
+      } handle;
+
+      // an ordinary data pointer
+      struct
+      {
+         const void *vec_base;
+         int32_t vec_len;
+      } ptr;
+
+      // a nested vector list
+      struct
+      {
+         struct vchi_msg_vector_ex *vec;
+         uint32_t vec_len;
+      } list;
+   } u;
+} VCHI_MSG_VECTOR_EX_T;
+
+
+// Construct an entry in a msg vector for a pointer (p) of length (l)
+#define VCHI_VEC_POINTER(p,l)  VCHI_VEC_POINTER, { { (VCHI_MEM_HANDLE_T)(p), (l) } }
+
+// Construct an entry in a msg vector for a message handle (h), starting at offset (o) of length (l)
+#define VCHI_VEC_HANDLE(h,o,l) VCHI_VEC_HANDLE,  { { (h), (o), (l) } }
+
+// Macros to manipulate fourcc_t values
+#define MAKE_FOURCC(x) ((fourcc_t)( (x[0] << 24) | (x[1] << 16) | (x[2] << 8) | x[3] ))
+#define FOURCC_TO_CHAR(x) (x >> 24) & 0xFF,(x >> 16) & 0xFF,(x >> 8) & 0xFF, x & 0xFF
+
+
+// Opaque service information
+struct opaque_vchi_service_t;
+
+// Descriptor for a held message. Allocated by client, initialised by vchi_msg_hold,
+// vchi_msg_iter_hold or vchi_msg_iter_hold_next. Fields are for internal VCHI use only.
+typedef struct
+{
+   struct opaque_vchi_service_t *service;
+   void *message;
+} VCHI_HELD_MSG_T;
+
+
+
+// structure used to provide the information needed to open a server or a client
+typedef struct {
+   vcos_fourcc_t service_id;
+   VCHI_CONNECTION_T *connection;
+   uint32_t rx_fifo_size;
+   uint32_t tx_fifo_size;
+   VCHI_CALLBACK_T callback;
+   void *callback_param;
+   vcos_bool_t want_unaligned_bulk_rx;    // client intends to receive bulk transfers of odd lengths or into unaligned buffers
+   vcos_bool_t want_unaligned_bulk_tx;    // client intends to transmit bulk transfers of odd lengths or out of unaligned buffers
+   vcos_bool_t want_crc;                  // client wants to check CRCs on (bulk) transfers. Only needs to be set at 1 end - will do both directions.
+} SERVICE_CREATION_T;
+
+// Opaque handle for a VCHI instance
+typedef struct opaque_vchi_instance_handle_t *VCHI_INSTANCE_T;
+
+// Opaque handle for a server or client
+typedef struct opaque_vchi_service_handle_t *VCHI_SERVICE_HANDLE_T;
+
+// Service registration & startup
+typedef void (*VCHI_SERVICE_INIT)(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections);
+
+typedef struct service_info_tag {
+   const char * const vll_filename; /* VLL to load to start this service. This is an empty string if VLL is "static" */
+   VCHI_SERVICE_INIT init;          /* Service initialisation function */
+   void *vll_handle;                /* VLL handle; NULL when unloaded or a "static VLL" in build */
+} SERVICE_INFO_T;
+
+/******************************************************************************
+ Global funcs - implementation is specific to which side you are on (local / remote)
+ *****************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern /*@observer@*/ VCHI_CONNECTION_T * vchi_create_connection( const VCHI_CONNECTION_API_T * function_table,
+                                                   const VCHI_MESSAGE_DRIVER_T * low_level);
+
+
+// Routine used to initialise the vchi on both local + remote connections
+extern int32_t vchi_initialise( VCHI_INSTANCE_T *instance_handle );
+
+extern int32_t vchi_exit( void );
+
+extern int32_t vchi_connect( VCHI_CONNECTION_T **connections,
+                             const uint32_t num_connections,
+                             VCHI_INSTANCE_T instance_handle );
+
+//When this is called, ensure that all services have no data pending.
+//Bulk transfers can remain 'queued'
+extern int32_t vchi_disconnect( VCHI_INSTANCE_T instance_handle );
+
+// Global control over bulk CRC checking
+extern int32_t vchi_crc_control( VCHI_CONNECTION_T *connection,
+                                 VCHI_CRC_CONTROL_T control );
+
+// helper functions
+extern void * vchi_allocate_buffer(VCHI_SERVICE_HANDLE_T handle, uint32_t *length);
+extern void vchi_free_buffer(VCHI_SERVICE_HANDLE_T handle, void *address);
+extern uint32_t vchi_current_time(VCHI_INSTANCE_T instance_handle);
+
+
+/******************************************************************************
+ Global service API
+ *****************************************************************************/
+// Routine to create a named service
+extern int32_t vchi_service_create( VCHI_INSTANCE_T instance_handle,
+                                    SERVICE_CREATION_T *setup,
+                                    VCHI_SERVICE_HANDLE_T *handle );
+
+// Routine to destory a service
+extern int32_t vchi_service_destroy( const VCHI_SERVICE_HANDLE_T handle );
+
+// Routine to open a named service
+extern int32_t vchi_service_open( VCHI_INSTANCE_T instance_handle,
+                                  SERVICE_CREATION_T *setup,
+                                  VCHI_SERVICE_HANDLE_T *handle);
+
+// Routine to close a named service
+extern int32_t vchi_service_close( const VCHI_SERVICE_HANDLE_T handle );
+
+// Routine to increment ref count on a named service
+extern int32_t vchi_service_use( const VCHI_SERVICE_HANDLE_T handle );
+
+// Routine to decrement ref count on a named service
+extern int32_t vchi_service_release( const VCHI_SERVICE_HANDLE_T handle );
+
+// Routine to send a message accross a service
+extern int32_t vchi_msg_queue( VCHI_SERVICE_HANDLE_T handle,
+                               const void *data,
+                               uint32_t data_size,
+                               VCHI_FLAGS_T flags,
+                               void *msg_handle );
+
+// scatter-gather (vector) and send message
+int32_t vchi_msg_queuev_ex( VCHI_SERVICE_HANDLE_T handle,
+                            VCHI_MSG_VECTOR_EX_T *vector,
+                            uint32_t count,
+                            VCHI_FLAGS_T flags,
+                            void *msg_handle );
+
+// legacy scatter-gather (vector) and send message, only handles pointers
+int32_t vchi_msg_queuev( VCHI_SERVICE_HANDLE_T handle,
+                         VCHI_MSG_VECTOR_T *vector,
+                         uint32_t count,
+                         VCHI_FLAGS_T flags,
+                         void *msg_handle );
+
+// Routine to receive a msg from a service
+// Dequeue is equivalent to hold, copy into client buffer, release
+extern int32_t vchi_msg_dequeue( VCHI_SERVICE_HANDLE_T handle,
+                                 void *data,
+                                 uint32_t max_data_size_to_read,
+                                 uint32_t *actual_msg_size,
+                                 VCHI_FLAGS_T flags );
+
+// Routine to look at a message in place.
+// The message is not dequeued, so a subsequent call to peek or dequeue
+// will return the same message.
+extern int32_t vchi_msg_peek( VCHI_SERVICE_HANDLE_T handle,
+                              void **data,
+                              uint32_t *msg_size,
+                              VCHI_FLAGS_T flags );
+
+// Routine to remove a message after it has been read in place with peek
+// The first message on the queue is dequeued.
+extern int32_t vchi_msg_remove( VCHI_SERVICE_HANDLE_T handle );
+
+// Routine to look at a message in place.
+// The message is dequeued, so the caller is left holding it; the descriptor is
+// filled in and must be released when the user has finished with the message.
+extern int32_t vchi_msg_hold( VCHI_SERVICE_HANDLE_T handle,
+                              void **data,        // } may be NULL, as info can be
+                              uint32_t *msg_size, // } obtained from HELD_MSG_T
+                              VCHI_FLAGS_T flags,
+                              VCHI_HELD_MSG_T *message_descriptor );
+
+// Initialise an iterator to look through messages in place
+extern int32_t vchi_msg_look_ahead( VCHI_SERVICE_HANDLE_T handle,
+                                    VCHI_MSG_ITER_T *iter,
+                                    VCHI_FLAGS_T flags );
+
+/******************************************************************************
+ Global service support API - operations on held messages and message iterators
+ *****************************************************************************/
+
+// Routine to get the address of a held message
+extern void *vchi_held_msg_ptr( const VCHI_HELD_MSG_T *message );
+
+// Routine to get the size of a held message
+extern int32_t vchi_held_msg_size( const VCHI_HELD_MSG_T *message );
+
+// Routine to get the transmit timestamp as written into the header by the peer
+extern uint32_t vchi_held_msg_tx_timestamp( const VCHI_HELD_MSG_T *message );
+
+// Routine to get the reception timestamp, written as we parsed the header
+extern uint32_t vchi_held_msg_rx_timestamp( const VCHI_HELD_MSG_T *message );
+
+// Routine to release a held message after it has been processed
+extern int32_t vchi_held_msg_release( VCHI_HELD_MSG_T *message );
+
+// Indicates whether the iterator has a next message.
+extern vcos_bool_t vchi_msg_iter_has_next( const VCHI_MSG_ITER_T *iter );
+
+// Return the pointer and length for the next message and advance the iterator.
+extern int32_t vchi_msg_iter_next( VCHI_MSG_ITER_T *iter,
+                                   void **data,
+                                   uint32_t *msg_size );
+
+// Remove the last message returned by vchi_msg_iter_next.
+// Can only be called once after each call to vchi_msg_iter_next.
+extern int32_t vchi_msg_iter_remove( VCHI_MSG_ITER_T *iter );
+
+// Hold the last message returned by vchi_msg_iter_next.
+// Can only be called once after each call to vchi_msg_iter_next.
+extern int32_t vchi_msg_iter_hold( VCHI_MSG_ITER_T *iter,
+                                   VCHI_HELD_MSG_T *message );
+
+// Return information for the next message, and hold it, advancing the iterator.
+extern int32_t vchi_msg_iter_hold_next( VCHI_MSG_ITER_T *iter,
+                                        void **data,        // } may be NULL
+                                        uint32_t *msg_size, // }
+                                        VCHI_HELD_MSG_T *message );
+
+
+/******************************************************************************
+ Global bulk API
+ *****************************************************************************/
+
+// Routine to prepare interface for a transfer from the other side
+extern int32_t vchi_bulk_queue_receive( VCHI_SERVICE_HANDLE_T handle,
+                                        void *data_dst,
+                                        uint32_t data_size,
+                                        VCHI_FLAGS_T flags,
+                                        void *transfer_handle );
+
+
+// Prepare interface for a transfer from the other side into relocatable memory.
+int32_t vchi_bulk_queue_receive_reloc( const VCHI_SERVICE_HANDLE_T handle,
+                                       VCHI_MEM_HANDLE_T h_dst,
+                                       uint32_t offset,
+                                       uint32_t data_size,
+                                       const VCHI_FLAGS_T flags,
+                                       void * const bulk_handle );
+
+// Routine to queue up data ready for transfer to the other (once they have signalled they are ready)
+extern int32_t vchi_bulk_queue_transmit( VCHI_SERVICE_HANDLE_T handle,
+                                         const void *data_src,
+                                         uint32_t data_size,
+                                         VCHI_FLAGS_T flags,
+                                         void *transfer_handle );
+
+
+/******************************************************************************
+ Configuration plumbing
+ *****************************************************************************/
+
+// function prototypes for the different mid layers (the state info gives the different physical connections)
+extern const VCHI_CONNECTION_API_T *single_get_func_table( void );
+//extern const VCHI_CONNECTION_API_T *local_server_get_func_table( void );
+//extern const VCHI_CONNECTION_API_T *local_client_get_func_table( void );
+
+// declare all message drivers here
+const VCHI_MESSAGE_DRIVER_T *vchi_mphi_message_driver_func_table( void );
+
+#ifdef __cplusplus
+}
+#endif
+
+extern int32_t vchi_bulk_queue_transmit_reloc( VCHI_SERVICE_HANDLE_T handle,
+                                               VCHI_MEM_HANDLE_T h_src,
+                                               uint32_t offset,
+                                               uint32_t data_size,
+                                               VCHI_FLAGS_T flags,
+                                               void *transfer_handle );
+#endif /* VCHI_H_ */
+
+/****************************** End of file **********************************/
diff --git a/drivers/misc/vc04_services/interface/vchi/vchi_cfg.h b/drivers/misc/vc04_services/interface/vchi/vchi_cfg.h
new file mode 100644
index 0000000..a66e489
--- /dev/null
+++ b/drivers/misc/vc04_services/interface/vchi/vchi_cfg.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2010-2011 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*=============================================================================
+Contains the #defines for the number of servers / clients etc, these can be
+over-ridden from the platform makefile if needed
+=============================================================================*/
+
+#ifndef VCHI_CFG_H_
+#define VCHI_CFG_H_
+
+/****************************************************************************************
+ * Defines in this first section are part of the VCHI API and may be examined by VCHI
+ * services.
+ ***************************************************************************************/
+
+/* Required alignment of base addresses for bulk transfer, if unaligned transfers are not enabled */
+/* Really determined by the message driver, and should be available from a run-time call. */
+#ifndef VCHI_BULK_ALIGN
+#   if __VCCOREVER__ >= 0x04000000
+#       define VCHI_BULK_ALIGN 32 // Allows for the need to do cache cleans
+#   else
+#       define VCHI_BULK_ALIGN 16
+#   endif
+#endif
+
+/* Required length multiple for bulk transfers, if unaligned transfers are not enabled */
+/* May be less than or greater than VCHI_BULK_ALIGN */
+/* Really determined by the message driver, and should be available from a run-time call. */
+#ifndef VCHI_BULK_GRANULARITY
+#   if __VCCOREVER__ >= 0x04000000
+#       define VCHI_BULK_GRANULARITY 32 // Allows for the need to do cache cleans
+#   else
+#       define VCHI_BULK_GRANULARITY 16
+#   endif
+#endif
+
+/* The largest possible message to be queued with vchi_msg_queue. */
+#ifndef VCHI_MAX_MSG_SIZE
+#   if defined VCHI_LOCAL_HOST_PORT
+#       define VCHI_MAX_MSG_SIZE     16384         // makes file transfers fast, but should they be using bulk?
+#   else
+#       define VCHI_MAX_MSG_SIZE      4096 // NOTE: THIS MUST BE LARGER THAN OR EQUAL TO THE SIZE OF THE KHRONOS MERGE BUFFER!!
+#   endif
+#endif
+
+/******************************************************************************************
+ * Defines below are system configuration options, and should not be used by VCHI services.
+ *****************************************************************************************/
+
+/* How many connections can we support? A localhost implementation uses 2 connections,
+ * 1 for host-app, 1 for VMCS, and these are hooked together by a loopback MPHI VCFW
+ * driver. */
+#ifndef VCHI_MAX_NUM_CONNECTIONS
+#   define VCHI_MAX_NUM_CONNECTIONS 3
+#endif
+
+/* How many services can we open per connection? Extending this doesn't cost processing time, just a small
+ * amount of static memory. */
+#ifndef VCHI_MAX_SERVICES_PER_CONNECTION
+#  define VCHI_MAX_SERVICES_PER_CONNECTION 36
+#endif
+
+/* Adjust if using a message driver that supports more logical TX channels */
+#ifndef VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION
+#   define VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION 9 // 1 MPHI + 8 CCP2 logical channels
+#endif
+
+/* Adjust if using a message driver that supports more logical RX channels */
+#ifndef VCHI_MAX_BULK_RX_CHANNELS_PER_CONNECTION
+#   define VCHI_MAX_BULK_RX_CHANNELS_PER_CONNECTION 1 // 1 MPHI
+#endif
+
+/* How many receive slots do we use. This times VCHI_MAX_MSG_SIZE gives the effective
+ * receive queue space, less message headers. */
+#ifndef VCHI_NUM_READ_SLOTS
+#  if defined(VCHI_LOCAL_HOST_PORT)
+#     define VCHI_NUM_READ_SLOTS 4
+#  else
+#     define VCHI_NUM_READ_SLOTS 48
+#  endif
+#endif
+
+/* Do we utilise overrun facility for receive message slots? Can aid peer transmit
+ * performance. Only define on VideoCore end, talking to host.
+ */
+//#define VCHI_MSG_RX_OVERRUN
+
+/* How many transmit slots do we use. Generally don't need many, as the hardware driver
+ * underneath VCHI will usually have its own buffering. */
+#ifndef VCHI_NUM_WRITE_SLOTS
+#  define VCHI_NUM_WRITE_SLOTS 4
+#endif
+
+/* If a service has held or queued received messages in VCHI_XOFF_THRESHOLD or more slots,
+ * then it's taking up too much buffer space, and the peer service will be told to stop
+ * transmitting with an XOFF message. For this to be effective, the VCHI_NUM_READ_SLOTS
+ * needs to be considerably bigger than VCHI_NUM_WRITE_SLOTS, or the transmit latency
+ * is too high. */
+#ifndef VCHI_XOFF_THRESHOLD
+#  define VCHI_XOFF_THRESHOLD (VCHI_NUM_READ_SLOTS / 2)
+#endif
+
+/* After we've sent an XOFF, the peer will be told to resume transmission once the local
+ * service has dequeued/released enough messages that it's now occupying
+ * VCHI_XON_THRESHOLD slots or fewer. */
+#ifndef VCHI_XON_THRESHOLD
+#  define VCHI_XON_THRESHOLD (VCHI_NUM_READ_SLOTS / 4)
+#endif
+
+/* A size below which a bulk transfer omits the handshake completely and always goes
+ * via the message channel, if bulk auxiliary is being sent on that service. (The user
+ * can guarantee this by enabling unaligned transmits).
+ * Not API. */
+#ifndef VCHI_MIN_BULK_SIZE
+#  define VCHI_MIN_BULK_SIZE    ( VCHI_MAX_MSG_SIZE / 2 < 4096 ? VCHI_MAX_MSG_SIZE / 2 : 4096 )
+#endif
+
+/* Maximum size of bulk transmission chunks, for each interface type. A trade-off between
+ * speed and latency; the smaller the chunk size the better change of messages and other
+ * bulk transmissions getting in when big bulk transfers are happening. Set to 0 to not
+ * break transmissions into chunks.
+ */
+#ifndef VCHI_MAX_BULK_CHUNK_SIZE_MPHI
+#  define VCHI_MAX_BULK_CHUNK_SIZE_MPHI (16 * 1024)
+#endif
+
+/* NB Chunked CCP2 transmissions violate the letter of the CCP2 spec by using "JPEG8" mode
+ * with multiple-line frames. Only use if the receiver can cope. */
+#ifndef VCHI_MAX_BULK_CHUNK_SIZE_CCP2
+#  define VCHI_MAX_BULK_CHUNK_SIZE_CCP2 0
+#endif
+
+/* How many TX messages can we have pending in our transmit slots. Once exhausted,
+ * vchi_msg_queue will be blocked. */
+#ifndef VCHI_TX_MSG_QUEUE_SIZE
+#  define VCHI_TX_MSG_QUEUE_SIZE           256
+#endif
+
+/* How many RX messages can we have parsed in the receive slots. Once exhausted, parsing
+ * will be suspended until older messages are dequeued/released. */
+#ifndef VCHI_RX_MSG_QUEUE_SIZE
+#  define VCHI_RX_MSG_QUEUE_SIZE           256
+#endif
+
+/* Really should be able to cope if we run out of received message descriptors, by
+ * suspending parsing as the comment above says, but we don't. This sweeps the issue
+ * under the carpet. */
+#if VCHI_RX_MSG_QUEUE_SIZE < (VCHI_MAX_MSG_SIZE/16 + 1) * VCHI_NUM_READ_SLOTS
+#  undef VCHI_RX_MSG_QUEUE_SIZE
+#  define VCHI_RX_MSG_QUEUE_SIZE (VCHI_MAX_MSG_SIZE/16 + 1) * VCHI_NUM_READ_SLOTS
+#endif
+
+/* How many bulk transmits can we have pending. Once exhausted, vchi_bulk_queue_transmit
+ * will be blocked. */
+#ifndef VCHI_TX_BULK_QUEUE_SIZE
+#  define VCHI_TX_BULK_QUEUE_SIZE           64
+#endif
+
+/* How many bulk receives can we have pending. Once exhausted, vchi_bulk_queue_receive
+ * will be blocked. */
+#ifndef VCHI_RX_BULK_QUEUE_SIZE
+#  define VCHI_RX_BULK_QUEUE_SIZE           64
+#endif
+
+/* A limit on how many outstanding bulk requests we expect the peer to give us. If
+ * the peer asks for more than this, VCHI will fail and assert. The number is determined
+ * by the peer's hardware - it's the number of outstanding requests that can be queued
+ * on all bulk channels. VC3's MPHI peripheral allows 16. */
+#ifndef VCHI_MAX_PEER_BULK_REQUESTS
+#  define VCHI_MAX_PEER_BULK_REQUESTS       32
+#endif
+
+/* Define VCHI_CCP2TX_MANUAL_POWER if the host tells us when to turn the CCP2
+ * transmitter on and off.
+ */
+/*#define VCHI_CCP2TX_MANUAL_POWER*/
+
+#ifndef VCHI_CCP2TX_MANUAL_POWER
+
+/* Timeout (in milliseconds) for putting the CCP2TX interface into IDLE state. Set
+ * negative for no IDLE.
+ */
+#  ifndef VCHI_CCP2TX_IDLE_TIMEOUT
+#    define VCHI_CCP2TX_IDLE_TIMEOUT        5
+#  endif
+
+/* Timeout (in milliseconds) for putting the CCP2TX interface into OFF state. Set
+ * negative for no OFF.
+ */
+#  ifndef VCHI_CCP2TX_OFF_TIMEOUT
+#    define VCHI_CCP2TX_OFF_TIMEOUT         1000
+#  endif
+
+#endif /* VCHI_CCP2TX_MANUAL_POWER */
+
+#endif /* VCHI_CFG_H_ */
+
+/****************************** End of file **********************************/
diff --git a/drivers/misc/vc04_services/interface/vchi/vchi_cfg_internal.h b/drivers/misc/vc04_services/interface/vchi/vchi_cfg_internal.h
new file mode 100644
index 0000000..958cc55
--- /dev/null
+++ b/drivers/misc/vc04_services/interface/vchi/vchi_cfg_internal.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2010-2011 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef VCHI_CFG_INTERNAL_H_
+#define VCHI_CFG_INTERNAL_H_
+
+/****************************************************************************************
+ * Control optimisation attempts.
+ ***************************************************************************************/
+
+// Don't use lots of short-term locks - use great long ones, reducing the overall locks-per-second
+#define VCHI_COARSE_LOCKING
+
+// Avoid lock then unlock on exit from blocking queue operations (msg tx, bulk rx/tx)
+// (only relevant if VCHI_COARSE_LOCKING)
+#define VCHI_ELIDE_BLOCK_EXIT_LOCK
+
+// Avoid lock on non-blocking peek
+// (only relevant if VCHI_COARSE_LOCKING)
+#define VCHI_AVOID_PEEK_LOCK
+
+// Use one slot-handler thread per connection, rather than 1 thread dealing with all connections in rotation.
+#define VCHI_MULTIPLE_HANDLER_THREADS
+
+// Put free descriptors onto the head of the free queue, rather than the tail, so that we don't thrash
+// our way through the pool of descriptors.
+#define VCHI_PUSH_FREE_DESCRIPTORS_ONTO_HEAD
+
+// Don't issue a MSG_AVAILABLE callback for every single message. Possibly only safe if VCHI_COARSE_LOCKING.
+#define VCHI_FEWER_MSG_AVAILABLE_CALLBACKS
+
+// Don't use message descriptors for TX messages that don't need them
+#define VCHI_MINIMISE_TX_MSG_DESCRIPTORS
+
+// Nano-locks for multiqueue
+//#define VCHI_MQUEUE_NANOLOCKS
+
+// Lock-free(er) dequeuing
+//#define VCHI_RX_NANOLOCKS
+
+#endif /*VCHI_CFG_INTERNAL_H_*/
diff --git a/drivers/misc/vc04_services/interface/vchi/vchi_common.h b/drivers/misc/vc04_services/interface/vchi/vchi_common.h
new file mode 100644
index 0000000..4057878
--- /dev/null
+++ b/drivers/misc/vc04_services/interface/vchi/vchi_common.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2010-2011 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*=============================================================================
+Contains global defs used by submodules within vchi.
+=============================================================================*/
+
+#ifndef VCHI_COMMON_H_
+#define VCHI_COMMON_H_
+
+
+//flags used when sending messages (must be bitmapped)
+typedef enum
+{
+   VCHI_FLAGS_NONE                      = 0x0,
+   VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE   = 0x1,   // waits for message to be received, or sent (NB. not the same as being seen on other side)
+   VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE = 0x2,   // run a callback when message sent
+   VCHI_FLAGS_BLOCK_UNTIL_QUEUED        = 0x4,   // return once the transfer is in a queue ready to go
+   VCHI_FLAGS_ALLOW_PARTIAL             = 0x8,
+   VCHI_FLAGS_BLOCK_UNTIL_DATA_READ     = 0x10,
+   VCHI_FLAGS_CALLBACK_WHEN_DATA_READ   = 0x20,
+
+   VCHI_FLAGS_ALIGN_SLOT            = 0x000080,  // internal use only
+   VCHI_FLAGS_BULK_AUX_QUEUED       = 0x010000,  // internal use only
+   VCHI_FLAGS_BULK_AUX_COMPLETE     = 0x020000,  // internal use only
+   VCHI_FLAGS_BULK_DATA_QUEUED      = 0x040000,  // internal use only
+   VCHI_FLAGS_BULK_DATA_COMPLETE    = 0x080000,  // internal use only
+   VCHI_FLAGS_INTERNAL              = 0xFF0000
+} VCHI_FLAGS_T;
+
+// constants for vchi_crc_control()
+typedef enum {
+   VCHI_CRC_NOTHING = -1,
+   VCHI_CRC_PER_SERVICE = 0,
+   VCHI_CRC_EVERYTHING = 1,
+} VCHI_CRC_CONTROL_T;
+
+//callback reasons when an event occurs on a service
+typedef enum
+{
+   VCHI_CALLBACK_REASON_MIN,
+
+   //This indicates that there is data available
+   //handle is the msg id that was transmitted with the data
+   //    When a message is received and there was no FULL message available previously, send callback
+   //    Tasks get kicked by the callback, reset their event and try and read from the fifo until it fails
+   VCHI_CALLBACK_MSG_AVAILABLE,
+   VCHI_CALLBACK_MSG_SENT,
+   VCHI_CALLBACK_MSG_SPACE_AVAILABLE, // XXX not yet implemented
+
+   // This indicates that a transfer from the other side has completed
+   VCHI_CALLBACK_BULK_RECEIVED,
+   //This indicates that data queued up to be sent has now gone
+   //handle is the msg id that was used when sending the data
+   VCHI_CALLBACK_BULK_SENT,
+   VCHI_CALLBACK_BULK_RX_SPACE_AVAILABLE, // XXX not yet implemented
+   VCHI_CALLBACK_BULK_TX_SPACE_AVAILABLE, // XXX not yet implemented
+
+   VCHI_CALLBACK_SERVICE_CLOSED,
+
+   // this side has sent XOFF to peer due to lack of data consumption by service
+   // (suggests the service may need to take some recovery action if it has
+   // been deliberately holding off consuming data)
+   VCHI_CALLBACK_SENT_XOFF,
+   VCHI_CALLBACK_SENT_XON,
+
+   // indicates that a bulk transfer has finished reading the source buffer
+   VCHI_CALLBACK_BULK_DATA_READ,
+
+   // power notification events (currently host side only)
+   VCHI_CALLBACK_PEER_OFF,
+   VCHI_CALLBACK_PEER_SUSPENDED,
+   VCHI_CALLBACK_PEER_ON,
+   VCHI_CALLBACK_PEER_RESUMED,
+   VCHI_CALLBACK_FORCED_POWER_OFF,
+
+#ifdef USE_VCHIQ_ARM
+   // some extra notifications provided by vchiq_arm
+   VCHI_CALLBACK_SERVICE_OPENED,
+   VCHI_CALLBACK_BULK_RECEIVE_ABORTED,
+   VCHI_CALLBACK_BULK_TRANSMIT_ABORTED,
+#endif
+
+   VCHI_CALLBACK_REASON_MAX
+} VCHI_CALLBACK_REASON_T;
+
+//Calback used by all services / bulk transfers
+typedef void (*VCHI_CALLBACK_T)( void *callback_param, //my service local param
+                                 VCHI_CALLBACK_REASON_T reason,
+                                 void *handle ); //for transmitting msg's only
+
+
+
+/*
+ * Define vector struct for scatter-gather (vector) operations
+ * Vectors can be nested - if a vector element has negative length, then
+ * the data pointer is treated as pointing to another vector array, with
+ * '-vec_len' elements. Thus to append a header onto an existing vector,
+ * you can do this:
+ *
+ * void foo(const VCHI_MSG_VECTOR_T *v, int n)
+ * {
+ *    VCHI_MSG_VECTOR_T nv[2];
+ *    nv[0].vec_base = my_header;
+ *    nv[0].vec_len = sizeof my_header;
+ *    nv[1].vec_base = v;
+ *    nv[1].vec_len = -n;
+ *    ...
+ *
+ */
+typedef struct vchi_msg_vector {
+   const void *vec_base;
+   int32_t vec_len;
+} VCHI_MSG_VECTOR_T;
+
+// Opaque type for a connection API
+typedef struct opaque_vchi_connection_api_t VCHI_CONNECTION_API_T;
+
+// Opaque type for a message driver
+typedef struct opaque_vchi_message_driver_t VCHI_MESSAGE_DRIVER_T;
+
+
+// Iterator structure for reading ahead through received message queue. Allocated by client,
+// initialised by vchi_msg_look_ahead. Fields are for internal VCHI use only.
+// Iterates over messages in queue at the instant of the call to vchi_msg_lookahead -
+// will not proceed to messages received since. Behaviour is undefined if an iterator
+// is used again after messages for that service are removed/dequeued by any
+// means other than vchi_msg_iter_... calls on the iterator itself.
+typedef struct {
+   struct opaque_vchi_service_t *service;
+   void *last;
+   void *next;
+   void *remove;
+} VCHI_MSG_ITER_T;
+
+
+#endif // VCHI_COMMON_H_
diff --git a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c
index a3d8f3c..35f6afe 100644
--- a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c
+++ b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c
@@ -36,7 +36,7 @@
 #define TOTAL_SLOTS (VCHIQ_SLOT_ZERO_SLOTS + 2 * 32)
 
 #define VCHIQ_DOORBELL_IRQ IRQ_ARM_DOORBELL_0
-#define VCHIQ_ARM_ADDRESS(x) __virt_to_bus((unsigned)x)
+#define VCHIQ_ARM_ADDRESS(x) ((void *)__virt_to_bus((unsigned)x))
 
 #include "vchiq_arm.h"
 #include "vchiq_2835.h"
@@ -182,7 +182,15 @@ remote_event_signal(REMOTE_EVENT_T *event)
 int
 vchiq_copy_from_user(void *dst, const void *src, int size)
 {
-	return copy_from_user(dst, src, size);
+	if ( (uint32_t)src < TASK_SIZE)
+	{
+		return copy_from_user(dst, src, size);
+	}
+	else
+	{
+		memcpy( dst, src, size );
+		return 0;
+	}
 }
 
 VCHIQ_STATUS_T
@@ -239,6 +247,22 @@ vchiq_dump_platform_state(void *dump_context)
         vchiq_dump(dump_context, buf, len + 1);
 }
 
+VCHIQ_STATUS_T
+vchiq_platform_suspend(VCHIQ_STATE_T *state)
+{
+   vcos_unused(state);
+   vcos_assert_msg(0, "Suspend/resume not supported");
+   return VCHIQ_ERROR;
+}
+
+VCHIQ_STATUS_T
+vchiq_platform_resume(VCHIQ_STATE_T *state)
+{
+   vcos_unused(state);
+   vcos_assert_msg(0, "Suspend/resume not supported");
+   return VCHIQ_ERROR;
+}
+
 void
 vchiq_platform_paused(VCHIQ_STATE_T *state)
 {
@@ -253,33 +277,40 @@ vchiq_platform_resumed(VCHIQ_STATE_T *state)
    vcos_assert_msg(0, "Suspend/resume not supported");
 }
 
-VCHIQ_STATUS_T
-vchiq_use_service(VCHIQ_SERVICE_HANDLE_T handle)
+int
+vchiq_platform_videocore_wanted(VCHIQ_STATE_T* state)
 {
-   VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
-   if (!service)
-      return VCHIQ_ERROR;
-   return VCHIQ_SUCCESS;
+   vcos_unused(state);
+   return 1; // autosuspend not supported - videocore always wanted
 }
 
-VCHIQ_STATUS_T
-vchiq_release_service(VCHIQ_SERVICE_HANDLE_T handle)
+#if VCOS_HAVE_TIMER
+int
+vchiq_platform_use_suspend_timer(void)
 {
-   VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
-   if (!service)
-      return VCHIQ_ERROR;
-   return VCHIQ_SUCCESS;
+   return 0;
+}
+#endif
+void
+vchiq_dump_platform_use_state(VCHIQ_STATE_T *state)
+{
+   vcos_unused(state);
 }
 
 VCHIQ_STATUS_T
-vchiq_check_service(VCHIQ_SERVICE_HANDLE_T handle)
+vchiq_platform_init_state(VCHIQ_STATE_T *state)
 {
-   VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
-   if (!service)
-      return VCHIQ_ERROR;
+   vcos_unused(state);
    return VCHIQ_SUCCESS;
 }
 
+VCHIQ_ARM_STATE_T*
+vchiq_platform_get_arm_state(VCHIQ_STATE_T *state)
+{
+   vcos_unused(state);
+   return NULL;
+}
+
 /*
  * Local functions
  */
@@ -479,9 +510,3 @@ free_pagelist(PAGELIST_T *pagelist, int actual)
 	kfree(pagelist);
 }
 
-VCHIQ_STATUS_T
-vchiq_platform_suspend(VCHIQ_STATE_T *state)
-{
-   vcos_unused(state);
-   return VCHIQ_ERROR;
-}
diff --git a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_arm.c b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_arm.c
index 2cb4364..6cc5300 100644
--- a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_arm.c
+++ b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_arm.c
@@ -23,6 +23,9 @@
 #include <linux/cdev.h>
 #include <linux/fs.h>
 #include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
 
 #include "vchiq_core.h"
 #include "vchiq_ioctl.h"
@@ -44,6 +47,15 @@
 
 #define VCOS_LOG_CATEGORY (&vchiq_arm_log_category)
 
+#define VCHIQ_ARM_VCSUSPEND_TASK_STACK 4096
+
+#if VCOS_HAVE_TIMER
+#define SUSPEND_TIMER_TIMEOUT_MS 100
+static VCOS_TIMER_T      g_suspend_timer;
+static void suspend_timer_callback(void *context);
+#endif
+
+
 typedef struct client_service_struct {
    VCHIQ_SERVICE_T *service;
    void *userdata;
@@ -106,10 +118,17 @@ static const char *ioctl_names[] =
    "GET_CONFIG",
    "CLOSE_SERVICE",
    "USE_SERVICE",
-   "RELEASE_SERIVCE"
+   "RELEASE_SERVICE",
+   "SET_SERVICE_OPTION",
+   "DUMP_PHYS_MEM"
 };
 
-VCOS_LOG_LEVEL_T vchiq_default_arm_log_level = VCOS_LOG_WARN;
+vcos_static_assert(vcos_countof(ioctl_names) == (VCHIQ_IOC_MAX + 1));
+
+VCOS_LOG_LEVEL_T vchiq_default_arm_log_level = VCOS_LOG_ERROR;
+
+static void
+dump_phys_mem( void *virt_addr, uint32_t num_bytes );
 
 /****************************************************************************
 *
@@ -524,7 +543,7 @@ vchiq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
             status = (cmd == VCHIQ_IOC_USE_SERVICE) ? vchiq_use_service(&user_service->service->base) : vchiq_release_service(&user_service->service->base);
             if (status != VCHIQ_SUCCESS)
             {
-               ret = -EINVAL; // ???
+               ret = -EINVAL; /* ??? */
             }
          }
       }
@@ -872,6 +891,21 @@ vchiq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
       }
       break;
 
+   case VCHIQ_IOC_DUMP_PHYS_MEM:
+      {
+         VCHIQ_DUMP_MEM_T  args;
+
+         if (copy_from_user
+             (&args, (const void __user *)arg,
+              sizeof(args)) != 0) {
+            ret = -EFAULT;
+            break;
+         }
+         dump_phys_mem( args.virt_addr, args.num_bytes );
+      }
+      break;
+
+
    default:
       ret = -ENOTTY;
       break;
@@ -1153,6 +1187,88 @@ vchiq_dump_platform_service_state(void *dump_context, VCHIQ_SERVICE_T *service)
 
 /****************************************************************************
 *
+*   dump_user_mem
+*
+***************************************************************************/
+
+static void
+dump_phys_mem( void *virt_addr, uint32_t num_bytes )
+{
+   int            rc;
+   uint8_t       *end_virt_addr = virt_addr + num_bytes;
+   int            num_pages;
+   int            offset;
+   int            end_offset;
+   int            page_idx;
+   int            prev_idx;
+   struct page   *page;
+   struct page  **pages;
+   uint8_t       *kmapped_virt_ptr;
+
+   // Align virtAddr and endVirtAddr to 16 byte boundaries.
+
+   virt_addr = (void *)((unsigned long)virt_addr & ~0x0fuL );
+   end_virt_addr = (void *)(( (unsigned long)end_virt_addr + 15uL ) & ~0x0fuL);
+
+   offset = (int)(long)virt_addr & ( PAGE_SIZE - 1 );
+   end_offset = (int)(long)end_virt_addr & ( PAGE_SIZE - 1 );
+
+   num_pages = (offset + num_bytes + PAGE_SIZE - 1) / PAGE_SIZE;
+
+   if (( pages = kmalloc( sizeof( struct page *) * num_pages, GFP_KERNEL )) == NULL )
+   {
+      printk( KERN_ERR "Unable to allocation memory for %d pages\n", num_pages );
+      return;
+   }
+
+   down_read( &current->mm->mmap_sem );
+   rc = get_user_pages( current,                   /* task */
+                        current->mm,               /* mm */
+                        (unsigned long)virt_addr,  /* start */
+                        num_pages,                 /* len */
+                        0,                         /* write */
+                        0,                         /* force */
+                        pages,                     /* pages (array of pointers to page) */
+                        NULL );                    /* vmas */
+   up_read( &current->mm->mmap_sem );
+
+   prev_idx = -1;
+   page = NULL;
+
+   while ( offset < end_offset ) {
+
+      int page_offset = offset % PAGE_SIZE;
+      page_idx = offset / PAGE_SIZE;
+
+      if ( page_idx != prev_idx ) {
+
+         if (page != NULL) {
+            kunmap( page );
+         }
+         page = pages[page_idx];
+         kmapped_virt_ptr = kmap( page );
+
+         prev_idx = page_idx;
+      }
+
+      vcos_log_dump_mem_impl( &vchiq_arm_log_category, "ph",
+                              (uint32_t)(unsigned long)&kmapped_virt_ptr[page_offset],
+                              &kmapped_virt_ptr[page_offset], 16 );
+
+      offset += 16;
+   }
+   if (page != NULL) {
+      kunmap( page );
+   }
+
+   for ( page_idx = 0; page_idx < num_pages; page_idx++ ) {
+      page_cache_release( pages[page_idx] );
+   }
+   kfree( pages );
+}
+
+/****************************************************************************
+*
 *   vchiq_read
 *
 ***************************************************************************/
@@ -1204,6 +1320,498 @@ vchiq_fops = {
    .read = vchiq_read
 };
 
+/*
+ * Autosuspend related functionality
+ */
+
+static int vchiq_videocore_wanted(VCHIQ_STATE_T* state)
+{
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+   if(!arm_state)
+   { // autosuspend not supported - always return wanted
+      return 1;
+   }
+   else if(!arm_state->videocore_use_count)
+   { // usage count zero - check for override
+      return vchiq_platform_videocore_wanted(state);
+   }
+   else
+   { // non-zero usage count - videocore still required
+      return 1;
+   }
+}
+
+
+/* Called by the lp thread */
+static void *
+lp_func(void *v)
+{
+   VCHIQ_STATE_T *state = (VCHIQ_STATE_T *) v;
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+
+   while (1) {
+      vcos_event_wait(&arm_state->lp_evt);
+
+      vcos_mutex_lock(&arm_state->use_count_mutex);
+      if (!vchiq_videocore_wanted(state))
+      {
+         arm_state->suspend_pending = 1;
+      }
+      vcos_mutex_unlock(&arm_state->use_count_mutex);
+
+      vchiq_arm_vcsuspend(state);
+   }
+   return NULL;
+}
+/* Called by the hp thread */
+static void *
+hp_func(void *v)
+{
+   VCHIQ_STATE_T *state = (VCHIQ_STATE_T *) v;
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+   int send_pending;
+
+   while (1) {
+      vcos_event_wait(&arm_state->hp_evt);
+
+      send_pending = 0;
+
+      vcos_mutex_lock(&arm_state->use_count_mutex);
+      if (vchiq_videocore_wanted(state))
+      {
+         vchiq_arm_vcresume(state);
+      }
+      if(arm_state->use_notify_pending)
+      {
+         send_pending = 1;
+         arm_state->use_notify_pending = 0;
+      }
+      vcos_mutex_unlock(&arm_state->use_count_mutex);
+      if(send_pending)
+      {
+         vcos_log_info( "%s sending VCHIQ_MSG_REMOTE_USE_ACTIVE", __func__);
+         if ( vchiq_send_remote_use_active(state) != VCHIQ_SUCCESS)
+         {
+            BUG();  /* vc should be resumed, so shouldn't be a problem sending message */
+         }
+      }
+   }
+   return NULL;
+}
+
+VCHIQ_STATUS_T
+vchiq_arm_init_state(VCHIQ_STATE_T* state, VCHIQ_ARM_STATE_T *arm_state)
+{
+   VCHIQ_STATUS_T status = VCHIQ_SUCCESS;
+   VCOS_THREAD_ATTR_T attrs;
+   char threadname[10];
+
+   if(arm_state)
+   {
+      vcos_mutex_create(&arm_state->use_count_mutex, "v.use_count_mutex");
+      vcos_mutex_create(&arm_state->suspend_resume_mutex, "v.susp_res_mutex");
+
+      vcos_event_create(&arm_state->lp_evt, "LP_EVT");
+      vcos_event_create(&arm_state->hp_evt, "HP_EVT");
+
+      vcos_thread_attr_init(&attrs);
+      vcos_thread_attr_setstacksize(&attrs, VCHIQ_ARM_VCSUSPEND_TASK_STACK);
+      vcos_thread_attr_setpriority(&attrs, VCOS_THREAD_PRI_LOWEST);
+      vcos_snprintf(threadname, sizeof(threadname), "VCHIQl-%d", state->id);
+      if(vcos_thread_create(&arm_state->lp_thread, threadname, &attrs, lp_func, state) != VCOS_SUCCESS)
+      {
+         vcos_log_error("vchiq: FATAL: couldn't create thread %s", threadname);
+         status = VCHIQ_ERROR;
+      }
+      else
+      {
+         vcos_thread_attr_init(&attrs);
+         vcos_thread_attr_setstacksize(&attrs, VCHIQ_ARM_VCSUSPEND_TASK_STACK);
+         vcos_thread_attr_setpriority(&attrs, VCOS_THREAD_PRI_HIGHEST);
+         vcos_snprintf(threadname, sizeof(threadname), "VCHIQh-%d", state->id);
+
+         if(vcos_thread_create(&arm_state->hp_thread, threadname, &attrs, hp_func, state) != VCOS_SUCCESS)
+         {
+            vcos_log_error("vchiq: FATAL: couldn't create thread %s", threadname);
+            status = VCHIQ_ERROR;
+         }
+      }
+   }
+   return status;
+}
+
+
+VCHIQ_STATUS_T
+vchiq_arm_vcsuspend(VCHIQ_STATE_T *state)
+{
+   VCHIQ_STATUS_T status = VCHIQ_SUCCESS;
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+
+   if (state->conn_state != VCHIQ_CONNSTATE_CONNECTED)
+      return VCHIQ_ERROR;
+
+   if(arm_state->suspend_pending)
+   {
+      vcos_mutex_lock(&arm_state->suspend_resume_mutex);
+      if(arm_state->videocore_suspended)
+      {
+         vcos_log_info("%s - already suspended", __func__);
+      }
+      else
+      {
+         vcos_log_info("%s - suspending", __func__);
+
+         status = vchiq_platform_suspend(state);
+         arm_state->videocore_suspended = (status == VCHIQ_SUCCESS) ? 1 : 0;
+
+         vcos_mutex_unlock(&arm_state->suspend_resume_mutex);
+
+         vcos_mutex_lock(&arm_state->use_count_mutex);
+         if(!arm_state->suspend_pending)
+         { /* Something has changed the suspend_pending state while we were suspending.
+            Run the HP task to check if we need to resume */
+            vcos_log_info( "%s trigger HP task to check resume", __func__);
+            vcos_event_signal(&arm_state->hp_evt);
+         }
+         arm_state->suspend_pending = 0;
+         vcos_mutex_unlock(&arm_state->use_count_mutex);
+      }
+   }
+   else
+   {
+      vchiq_check_resume(state);
+   }
+   return status;
+}
+
+
+VCHIQ_STATUS_T
+vchiq_arm_vcresume(VCHIQ_STATE_T *state)
+{
+   VCHIQ_STATUS_T status = VCHIQ_SUCCESS;
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+   vcos_mutex_lock(&arm_state->suspend_resume_mutex);
+
+   status = vchiq_platform_resume(state);
+   arm_state->videocore_suspended = (status == VCHIQ_RETRY) ? 1 : 0;
+
+   vcos_mutex_unlock(&arm_state->suspend_resume_mutex);
+
+   return status;
+}
+
+void
+vchiq_check_resume(VCHIQ_STATE_T* state)
+{
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+   vcos_mutex_lock(&arm_state->use_count_mutex);
+
+   if (arm_state->videocore_suspended && vchiq_videocore_wanted(state))
+   { /* signal high priority task to resume vc */
+      vcos_event_signal(&arm_state->hp_evt);
+   }
+
+   vcos_mutex_unlock(&arm_state->use_count_mutex);
+}
+
+void
+vchiq_check_suspend(VCHIQ_STATE_T* state)
+{
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+
+   vcos_mutex_lock(&arm_state->use_count_mutex);
+
+   if (!arm_state->videocore_suspended && !vchiq_videocore_wanted(state))
+   { /* signal low priority task to suspend vc */
+      vcos_event_signal(&arm_state->lp_evt);
+   }
+
+   vcos_mutex_unlock(&arm_state->use_count_mutex);
+}
+
+
+
+static VCHIQ_STATUS_T
+vchiq_use_internal(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service, int block_while_resume)
+{
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+   VCHIQ_STATUS_T ret = VCHIQ_SUCCESS;
+   char entity[10];
+   int* entity_uc;
+
+   if(arm_state)
+   {
+      vcos_mutex_lock(&arm_state->use_count_mutex);
+
+      if (service)
+      {
+         sprintf(entity, "%c%c%c%c:%03d",VCHIQ_FOURCC_AS_4CHARS(service->base.fourcc), service->client_id);
+         entity_uc = &service->service_use_count;
+      }
+      else
+      {
+         sprintf(entity, "PEER:   ");
+         entity_uc = &arm_state->peer_use_count;
+      }
+
+      if (!arm_state->videocore_suspended && !vchiq_videocore_wanted(state))
+      {
+#if VCOS_HAVE_TIMER
+         if (vchiq_platform_use_suspend_timer())
+         {
+            vcos_log_trace( "%s %s - cancel suspend timer", __func__, entity);
+         }
+         vcos_timer_cancel(&g_suspend_timer);
+#endif
+      }
+
+      arm_state->videocore_use_count++;
+      (*entity_uc)++;
+      arm_state->suspend_pending = 0;
+
+      if (arm_state->videocore_suspended && vchiq_videocore_wanted(state))
+      {
+         vcos_log_info( "%s %s count %d, state count %d", __func__, entity, *entity_uc, arm_state->videocore_use_count);
+         if(block_while_resume)
+         {
+            ret = vchiq_arm_vcresume(state);
+         }
+         else
+         {
+            vcos_log_info( "%s trigger HP task to do resume", __func__); /* triggering is done below */
+         }
+      }
+      else
+      {
+         vcos_log_trace( "%s %s count %d, state count %d", __func__, entity, *entity_uc, arm_state->videocore_use_count);
+      }
+      if(!block_while_resume)
+      {
+         arm_state->use_notify_pending = 1;
+         vcos_event_signal(&arm_state->hp_evt); /* hp task will check if we need to resume and also send use notify */
+      }
+
+      if (ret == VCHIQ_RETRY)
+      { /* if we're told to retry, decrement the counters.  VCHIQ_ERROR probably means we're already resumed. */
+         (*entity_uc)--;
+         arm_state->videocore_use_count--;
+      }
+
+      vcos_mutex_unlock(&arm_state->use_count_mutex);
+   }
+   return ret;
+}
+
+static VCHIQ_STATUS_T
+vchiq_release_internal(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service)
+{
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+   VCHIQ_STATUS_T ret = VCHIQ_SUCCESS;
+   char entity[10];
+   int* entity_uc;
+
+   if(arm_state)
+   {
+      vcos_mutex_lock(&arm_state->use_count_mutex);
+
+      if (service)
+      {
+         sprintf(entity, "%c%c%c%c:%03d",VCHIQ_FOURCC_AS_4CHARS(service->base.fourcc), service->client_id);
+         entity_uc = &service->service_use_count;
+      }
+      else
+      {
+         sprintf(entity, "PEER:   ");
+         entity_uc = &arm_state->peer_use_count;
+      }
+
+      if (*entity_uc && arm_state->videocore_use_count)
+      {
+         arm_state->videocore_use_count--;
+         (*entity_uc)--;
+
+         if (!vchiq_videocore_wanted(state))
+         {
+#if VCOS_HAVE_TIMER
+            if (vchiq_platform_use_suspend_timer())
+            {
+               vcos_log_trace( "%s %s count %d, state count %d - starting suspend timer", __func__, entity, *entity_uc, arm_state->videocore_use_count);
+               vcos_timer_cancel(&g_suspend_timer);
+               vcos_timer_set(&g_suspend_timer, SUSPEND_TIMER_TIMEOUT_MS);
+            }
+            else
+#endif
+            {
+               vcos_log_info( "%s %s count %d, state count %d - suspend pending", __func__, entity, *entity_uc, arm_state->videocore_use_count);
+               vcos_event_signal(&arm_state->lp_evt); /* kick the lp thread to do the suspend */
+            }
+         }
+         else
+         {
+            vcos_log_trace( "%s %s count %d, state count %d", __func__, entity, *entity_uc, arm_state->videocore_use_count);
+         }
+      }
+      else
+      {
+         vcos_log_error( "%s %s ERROR releasing service; count %d, state count %d", __func__, entity, *entity_uc, arm_state->videocore_use_count);
+         ret = VCHIQ_ERROR;
+      }
+
+      vcos_mutex_unlock(&arm_state->use_count_mutex);
+   }
+   return ret;
+}
+
+VCHIQ_STATUS_T
+vchiq_on_remote_use(VCHIQ_STATE_T *state)
+{
+   vcos_log_info("%s state %p", __func__, state);
+   return state ? vchiq_use_internal(state, NULL, 0) : VCHIQ_ERROR;
+}
+
+VCHIQ_STATUS_T
+vchiq_on_remote_release(VCHIQ_STATE_T *state)
+{
+   vcos_log_info("%s state %p", __func__, state);
+   return state ? vchiq_release_internal(state, NULL) : VCHIQ_ERROR;
+}
+
+VCHIQ_STATUS_T
+vchiq_use_service_internal(VCHIQ_SERVICE_T *service)
+{
+   VCHIQ_STATE_T* state = NULL;
+
+   if (service)
+   {
+      state = service->state;
+   }
+
+   if (!service || !state)
+   {
+      return VCHIQ_ERROR;
+   }
+   return vchiq_use_internal(state, service, 1);
+}
+
+VCHIQ_STATUS_T
+vchiq_release_service_internal(VCHIQ_SERVICE_T *service)
+{
+   VCHIQ_STATE_T* state = NULL;
+
+   if (service)
+   {
+      state = service->state;
+   }
+
+   if (!service || !state)
+   {
+      return VCHIQ_ERROR;
+   }
+   return vchiq_release_internal(state, service);
+}
+
+
+#if VCOS_HAVE_TIMER
+static void suspend_timer_callback(void* context)
+{
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state((VCHIQ_STATE_T*)context);
+   vcos_log_info( "%s - suspend pending", __func__);
+   vcos_event_signal(&arm_state->lp_evt);
+}
+#endif
+
+VCHIQ_STATUS_T
+vchiq_use_service(VCHIQ_SERVICE_HANDLE_T handle)
+{
+   VCHIQ_STATUS_T ret = VCHIQ_ERROR;
+   VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *) handle;
+   if (service)
+   {
+      ret = vchiq_use_service_internal(service);
+   }
+   return ret;
+}
+
+VCHIQ_STATUS_T
+vchiq_release_service(VCHIQ_SERVICE_HANDLE_T handle)
+{
+   VCHIQ_STATUS_T ret = VCHIQ_ERROR;
+   VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *) handle;
+   if (service)
+   {
+      ret = vchiq_release_service_internal(service);
+   }
+   return ret;
+}
+
+void
+vchiq_dump_service_use_state(VCHIQ_STATE_T *state)
+{
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);
+   int i;
+   if(arm_state)
+   {
+      vcos_mutex_lock(&arm_state->suspend_resume_mutex);
+      if (arm_state->videocore_suspended)
+      {
+         vcos_log_warn("--VIDEOCORE SUSPENDED--");
+      }
+      else
+      {
+         vcos_log_warn("--VIDEOCORE AWAKE--");
+      }
+      for (i = 0; i < state->unused_service; i++) {
+         VCHIQ_SERVICE_T *service_ptr = state->services[i];
+         if (service_ptr && (service_ptr->srvstate != VCHIQ_SRVSTATE_FREE))
+         {
+            if (service_ptr->service_use_count)
+               vcos_log_error("----- %c%c%c%c:%d service count %d <-- preventing suspend", VCHIQ_FOURCC_AS_4CHARS(service_ptr->base.fourcc), service_ptr->client_id, service_ptr->service_use_count);
+            else
+               vcos_log_warn("----- %c%c%c%c:%d service count 0", VCHIQ_FOURCC_AS_4CHARS(service_ptr->base.fourcc), service_ptr->client_id);
+         }
+      }
+      vcos_log_warn("----- PEER use count count %d", arm_state->peer_use_count);
+      vcos_log_warn("--- Overall vchiq instance use count %d", arm_state->videocore_use_count);
+
+      vchiq_dump_platform_use_state(state);
+
+      vcos_mutex_unlock(&arm_state->suspend_resume_mutex);
+   }
+}
+
+VCHIQ_STATUS_T
+vchiq_check_service(VCHIQ_SERVICE_T * service)
+{
+   VCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(service->state);
+   VCHIQ_STATUS_T ret = VCHIQ_ERROR;
+   /* on 2835 vchiq does not have an arm_state */
+   if (!arm_state)
+      return VCHIQ_SUCCESS;
+   if (service && arm_state)
+   {
+      vcos_mutex_lock(&arm_state->use_count_mutex);
+      if (!service->service_use_count)
+      {
+         vcos_log_error( "%s ERROR - %c%c%c%c:%d service count %d, state count %d, videocore_suspended %d", __func__,VCHIQ_FOURCC_AS_4CHARS(service->base.fourcc), service->client_id, service->service_use_count, arm_state->videocore_use_count, arm_state->videocore_suspended);
+         vchiq_dump_service_use_state(service->state);
+         vcos_assert(0); // vcos_assert should kill the calling thread, so a user thread shouldn't be able to kill the kernel.
+      }
+      else
+      {
+         ret = VCHIQ_SUCCESS;
+      }
+      vcos_mutex_unlock(&arm_state->use_count_mutex);
+   }
+   return ret;
+}
+
+/* stub functions */
+void vchiq_on_remote_use_active(VCHIQ_STATE_T *state)
+{
+   vcos_unused(state);
+}
+
+
 /****************************************************************************
 *
 *   vchiq_init - called when the module is loaded.
@@ -1250,6 +1858,10 @@ vchiq_init(void)
    if (err != 0)
       goto failed_platform_init;
 
+#if VCOS_HAVE_TIMER
+   vcos_timer_create( &g_suspend_timer, "suspend_timer", suspend_timer_callback, (void*)(&g_state));
+#endif
+
    vcos_log_error("vchiq: initialised - version %d (min %d), device %d.%d",
       VCHIQ_VERSION, VCHIQ_VERSION_MIN,
       MAJOR(vchiq_devid), MINOR(vchiq_devid));
diff --git a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_arm.h b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_arm.h
index 679e0a3..24b42ff 100644
--- a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_arm.h
+++ b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_arm.h
@@ -21,6 +21,40 @@
 
 #include "vchiq_core.h"
 
+
+typedef struct vchiq_arm_state_struct {
+
+   VCOS_THREAD_T lp_thread;            /* processes low priority messages (eg suspend) */
+   VCOS_THREAD_T hp_thread;            /* processes high priority messages (eg resume) */
+
+   VCOS_EVENT_T lp_evt;
+   VCOS_EVENT_T hp_evt;
+
+   VCOS_MUTEX_T use_count_mutex;
+   VCOS_MUTEX_T suspend_resume_mutex;
+
+   int suspend_pending;
+
+   /* Global use count for videocore.
+    * This is equal to the sum of the use counts for all services.  When this hits
+    * zero the videocore suspend procedure will be initiated. */
+   int videocore_use_count;
+
+   /* Use count to track requests from videocore peer.
+    * This use count is not associated with a service, so needs to be tracked separately
+    * with the state.
+    */
+   int peer_use_count;
+
+   /* Flag to indicate whether videocore is currently suspended */
+   int videocore_suspended;
+
+   /* Flag to indicate whether a notification is pending back to videocore that it's
+    * "remote use request" has been actioned */
+   int use_notify_pending;
+} VCHIQ_ARM_STATE_T;
+
+
 extern VCOS_LOG_CAT_T vchiq_arm_log_category;
 
 extern int __init
@@ -35,4 +69,50 @@ vchiq_platform_exit(VCHIQ_STATE_T *state);
 extern VCHIQ_STATE_T *
 vchiq_get_state(void);
 
+extern VCHIQ_STATUS_T
+vchiq_arm_vcsuspend(VCHIQ_STATE_T *state);
+
+extern VCHIQ_STATUS_T
+vchiq_arm_vcresume(VCHIQ_STATE_T *state);
+
+extern VCHIQ_STATUS_T
+vchiq_arm_init_state(VCHIQ_STATE_T *state, VCHIQ_ARM_STATE_T *arm_state);
+
+extern void
+vchiq_check_resume(VCHIQ_STATE_T* state);
+
+extern void
+vchiq_check_suspend(VCHIQ_STATE_T* state);
+
+extern VCHIQ_STATUS_T
+vchiq_use_service(VCHIQ_SERVICE_HANDLE_T handle);
+
+extern VCHIQ_STATUS_T
+vchiq_release_service(VCHIQ_SERVICE_HANDLE_T handle);
+
+extern VCHIQ_STATUS_T
+vchiq_check_service(VCHIQ_SERVICE_T * service);
+
+extern VCHIQ_STATUS_T
+vchiq_platform_suspend(VCHIQ_STATE_T *state);
+
+extern VCHIQ_STATUS_T
+vchiq_platform_resume(VCHIQ_STATE_T *state);
+
+extern int
+vchiq_platform_videocore_wanted(VCHIQ_STATE_T* state);
+
+extern int
+vchiq_platform_use_suspend_timer(void);
+
+extern void
+vchiq_dump_platform_use_state(VCHIQ_STATE_T *state);
+
+extern void
+vchiq_dump_service_use_state(VCHIQ_STATE_T *state);
+
+extern VCHIQ_ARM_STATE_T*
+vchiq_platform_get_arm_state(VCHIQ_STATE_T *state);
+
+
 #endif /* VCHIQ_ARM_H */
diff --git a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_core.c b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_core.c
index 5f2d111..87a6a1a 100644
--- a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_core.c
+++ b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_core.c
@@ -30,6 +30,11 @@
 
 #define BULK_INDEX(x) (x & (VCHIQ_NUM_SERVICE_BULKS - 1))
 
+
+/* Used to check use counts allow vchiq use. */
+extern VCHIQ_STATUS_T vchiq_check_service(VCHIQ_SERVICE_T * service);
+
+
 typedef struct bulk_waiter_struct
 {
    VCOS_EVENT_T event;
@@ -114,6 +119,13 @@ vchiq_set_service_state(VCHIQ_SERVICE_T *service, int newstate)
    service->srvstate = newstate;
 }
 
+static inline int
+is_valid_service(VCHIQ_SERVICE_T *service)
+{
+   return ((service != NULL) &&
+      (service->srvstate != VCHIQ_SRVSTATE_FREE));
+}
+
 static inline VCHIQ_STATUS_T
 make_service_callback(VCHIQ_SERVICE_T *service, VCHIQ_REASON_T reason,
    VCHIQ_HEADER_T *header, void *bulk_userdata)
@@ -323,7 +335,7 @@ process_free_queue(VCHIQ_STATE_T *state)
 
    while (slot_queue_available != local->slot_queue_recycle)
    {
-      int pos;
+      unsigned int pos;
       int slot_index = local->slot_queue[slot_queue_available++ & VCHIQ_SLOT_QUEUE_MASK];
       char *data = (char *)SLOT_DATA_FROM_INDEX(state, slot_index);
 
@@ -343,17 +355,37 @@ process_free_queue(VCHIQ_STATE_T *state)
          if (VCHIQ_MSG_TYPE(msgid) == VCHIQ_MSG_DATA)
          {
             int port = VCHIQ_MSG_SRCPORT(msgid);
+            VCHIQ_SERVICE_QUOTA_T *service_quota =
+               &state->service_quotas[port];
+            int count;
+            count = service_quota->message_use_count;
+            if (count > 0)
+            {
+               service_quota->message_use_count = count - 1;
+               if (count == service_quota->message_quota)
+               {
+                  /* Signal the service that it has dropped below its quota */
+                  vcos_event_signal(&service_quota->quota_event);
+               }
+            }
+            else
+            {
+               vcos_log_error("service %d message_use_count=%d (header %x,"
+                              " msgid %x, header->msgid %x, header->size %x)",
+                  port, service_quota->message_use_count,
+                  (unsigned int)header, msgid, header->msgid,
+                  header->size);
+               vcos_assert(0);
+            }
             if (!BITSET_IS_SET(service_found, port))
             {
-               VCHIQ_SERVICE_QUOTA_T *service_quota =
-                  &state->service_quotas[port];
-
                /* Set the found bit for this service */
                BITSET_SET(service_found, port);
 
-               if (service_quota->slot_use_count > 0)
+               count = service_quota->slot_use_count;
+               if (count > 0)
                {
-                  service_quota->slot_use_count--;
+                  service_quota->slot_use_count = count - 1;
                   /* Signal the service in case it has dropped below its quota */
                   vcos_event_signal(&service_quota->quota_event);
                   vcos_log_trace("%d: pfq:%d %x@%x - slot_use->%d",
@@ -376,7 +408,7 @@ process_free_queue(VCHIQ_STATE_T *state)
          pos += calc_stride(header->size);
          if (pos > VCHIQ_SLOT_SIZE)
          {
-            vcos_log_error("pos %x: header %x, msgid %x, header->msgid %x, header->size %x",
+            vcos_log_error("pfq - pos %x: header %x, msgid %x, header->msgid %x, header->size %x",
                pos, (unsigned int)header, msgid, header->msgid, header->size);
             vcos_assert(0);
          }
@@ -431,20 +463,21 @@ queue_message(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service,
 
       service_quota = &state->service_quotas[service->localport];
 
-      /* ...ensure it doesn't use more than its quota of slots */
-      while ((tx_end_index != service_quota->previous_tx_index) &&
-         (service_quota->slot_use_count == service_quota->slot_quota))
+      /* ...ensure it doesn't use more than its quota of messages or slots */
+      while ((service_quota->message_use_count == service_quota->message_quota) ||
+         ((tx_end_index != service_quota->previous_tx_index) &&
+         (service_quota->slot_use_count == service_quota->slot_quota)))
       {
-         vcos_log_trace("%d: qm:%d %s,%x - quota stall",
+         vcos_log_trace("%d: qm:%d %s,%x - quota stall (msg %d, slot %d)",
             state->id, service->localport,
-            msg_type_str(VCHIQ_MSG_TYPE(msgid)), size);
+            msg_type_str(VCHIQ_MSG_TYPE(msgid)), size,
+            service_quota->message_use_count, service_quota->slot_use_count);
          VCHIQ_SERVICE_STATS_INC(service, quota_stalls);
          vcos_mutex_unlock(&state->slot_mutex);
          if (vcos_event_wait(&service_quota->quota_event) != VCOS_SUCCESS)
             return VCHIQ_RETRY;
          if (vcos_mutex_lock(&state->slot_mutex) != VCOS_SUCCESS)
             return VCHIQ_RETRY;
-         vcos_assert(service_quota->slot_use_count <= service_quota->slot_quota);
          tx_end_index = SLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos + stride - 1);
       }
    }
@@ -498,6 +531,7 @@ queue_message(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service,
       }
 
       service_quota->previous_tx_index = tx_end_index;
+      service_quota->message_use_count++;
       VCHIQ_SERVICE_STATS_INC(service, ctrl_tx_count);
       VCHIQ_SERVICE_STATS_ADD(service, ctrl_tx_bytes, size);
    } else {
@@ -1232,6 +1266,17 @@ parse_rx_slots(VCHIQ_STATE_T *state)
          vchiq_set_conn_state(state, VCHIQ_CONNSTATE_CONNECTED);
          vchiq_platform_resumed(state);
          break;
+
+      case VCHIQ_MSG_REMOTE_USE:
+         vchiq_on_remote_use(state);
+         break;
+      case VCHIQ_MSG_REMOTE_RELEASE:
+         vchiq_on_remote_release(state);
+         break;
+      case VCHIQ_MSG_REMOTE_USE_ACTIVE:
+         vchiq_on_remote_use_active(state);
+         break;
+
       default:
          vcos_log_error("%d: prs invalid msgid %x@%x,%x",
             state->id, msgid, (unsigned int)header, size);
@@ -1326,8 +1371,6 @@ slot_handler_func(void *v)
    return NULL;
 }
 
-extern VCHIQ_STATUS_T
-vchiq_platform_suspend(VCHIQ_STATE_T *state);
 
 /* Called by the recycle thread */
 static void *
@@ -1348,23 +1391,6 @@ recycle_func(void *v)
    return NULL;
 }
 
-/* Called by the lp thread */
-static void *
-lp_func(void *v)
-{
-   VCHIQ_STATE_T *state = (VCHIQ_STATE_T *) v;
-
-   while (1) {
-      vcos_event_wait(&state->lp_evt);
-      vcos_mutex_lock(&state->use_count_mutex);
-      if (state->videocore_use_count == 0)
-      {
-         vchiq_platform_suspend(state);
-      }
-      vcos_mutex_unlock(&state->use_count_mutex);
-   }
-   return NULL;
-}
 
 static void
 init_bulk_queue(VCHIQ_BULK_QUEUE_T *queue)
@@ -1417,6 +1443,7 @@ vchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero, int is_mast
    VCHIQ_SHARED_STATE_T *local;
    VCHIQ_SHARED_STATE_T *remote;
    VCOS_THREAD_ATTR_T attrs;
+   VCHIQ_STATUS_T status;
    char threadname[10];
    static int id = 0;
    int i;
@@ -1426,7 +1453,7 @@ vchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero, int is_mast
    vcos_log_register("vchiq_core", &vchiq_core_log_category);
    vcos_log_register("vchiq_core_msg", &vchiq_core_msg_log_category);
 
-   vcos_log_warn( "%s: slot_zero = 0x%08lx, is_master = %d\n", __func__, (unsigned long)slot_zero, is_master );
+   vcos_log_warn( "%s: slot_zero = 0x%08lx, is_master = %d", __func__, (unsigned long)slot_zero, is_master );
 
    /* Check the input configuration */
 
@@ -1501,6 +1528,7 @@ vchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero, int is_mast
    }
 
    memset(state, 0, sizeof(VCHIQ_STATE_T));
+   vcos_log_warn( "%s: called", __func__);
    state->id = id++;
    state->is_master = is_master;
 
@@ -1523,8 +1551,6 @@ vchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero, int is_mast
 
    vcos_mutex_create(&state->slot_mutex, "v.slot_mutex");
    vcos_mutex_create(&state->recycle_mutex, "v.recycle_mutex");
-   vcos_mutex_create(&state->use_count_mutex, "v.use_count_mutex");
-   vcos_mutex_create(&state->suspend_resume_mutex, "v.susp_res_mutex");
 
    vcos_event_create(&state->slot_available_event, "v.slot_available_event");
    vcos_event_create(&state->slot_remove_event, "v.slot_remove_event");
@@ -1543,6 +1569,7 @@ vchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero, int is_mast
    }
 
    state->default_slot_quota = state->slot_queue_available/2;
+   state->default_message_quota = vcos_min(state->default_slot_quota * 256, (unsigned short)~0);
 
    local->trigger.event = &state->trigger_event;
    remote_event_create(&local->trigger);
@@ -1552,8 +1579,6 @@ vchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero, int is_mast
    remote_event_create(&local->recycle);
    local->slot_queue_recycle = state->slot_queue_available;
 
-   vcos_event_create(&state->lp_evt, "LP_EVT");
-
    local->debug[DEBUG_ENTRIES] = DEBUG_MAX;
 
    /*
@@ -1566,7 +1591,10 @@ vchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero, int is_mast
    vcos_snprintf(threadname, sizeof(threadname), "VCHIQ-%d", state->id);
    if (vcos_thread_create(&state->slot_handler_thread, threadname,
             &attrs, slot_handler_func, state) != VCOS_SUCCESS)
+   {
+      vcos_log_error("vchiq: FATAL: couldn't create thread %s", threadname);
       return VCHIQ_ERROR;
+   }
 
    vcos_thread_attr_init(&attrs);
    vcos_thread_attr_setstacksize(&attrs, VCHIQ_SLOT_HANDLER_STACK);
@@ -1574,20 +1602,17 @@ vchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero, int is_mast
    vcos_snprintf(threadname, sizeof(threadname), "VCHIQr-%d", state->id);
    if (vcos_thread_create(&state->recycle_thread, threadname,
             &attrs, recycle_func, state) != VCOS_SUCCESS)
+   {
+      vcos_log_error("vchiq: FATAL: couldn't create thread %s", threadname);
       return VCHIQ_ERROR;
+   }
 
-   vcos_thread_attr_init(&attrs);
-   vcos_thread_attr_setstacksize(&attrs, VCHIQ_SLOT_HANDLER_STACK);
-   vcos_thread_attr_setpriority(&attrs, VCOS_THREAD_PRI_LOWEST);
-   vcos_snprintf(threadname, sizeof(threadname), "VCHIQl-%d", state->id);
-   if (vcos_thread_create(&state->lp_thread, threadname,
-            &attrs, lp_func, state) != VCOS_SUCCESS)
-      return VCHIQ_ERROR;
+   status = vchiq_platform_init_state(state);
 
    /* Indicate readiness to the other side */
    local->initialised = 1;
 
-   return VCHIQ_SUCCESS;
+   return status;
 }
 
 /* Called from application thread when a client or server service is created. */
@@ -1684,6 +1709,7 @@ vchiq_add_service_internal(VCHIQ_STATE_T *state,
       init_bulk_queue(&service->bulk_tx);
       init_bulk_queue(&service->bulk_rx);
       service_quota->slot_quota = state->default_slot_quota;
+      service_quota->message_quota = state->default_message_quota;
       if (service_quota->slot_use_count == 0)
          service_quota->previous_tx_index =
             SLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos) - 1;
@@ -1833,9 +1859,13 @@ vchiq_close_service_internal(VCHIQ_SERVICE_T *service, int close_recvd)
 
    if (service->srvstate == VCHIQ_SRVSTATE_CLOSING)
    {
+      int i;
+      int uc = service->service_use_count;
       /* Complete the close process */
-      vchiq_release_service(&service->base);
-
+      for( i=0; i<uc; i++)
+      { /* cater for cases where close is forced and the client may not close all it's handles */
+         vchiq_release_service_internal(service);
+      }
       service->client_id = 0;
 
       /* Now tell the client that the services is closed */
@@ -1912,7 +1942,7 @@ vchiq_free_service_internal(VCHIQ_SERVICE_T *service)
       if (slot_info->release_count != slot_info->use_count)
       {
          char *data = (char *)SLOT_DATA_FROM_INDEX(state, i);
-         int pos, end;
+         unsigned int pos, end;
 
          end = VCHIQ_SLOT_SIZE;
          if (data == state->rx_data)
@@ -1938,6 +1968,12 @@ vchiq_free_service_internal(VCHIQ_SERVICE_T *service)
                }
             }
             pos += calc_stride(header->size);
+            if (pos > VCHIQ_SLOT_SIZE)
+            {
+               vcos_log_error("fsi - pos %x: header %x, msgid %x, header->msgid %x, header->size %x",
+                  pos, (unsigned int)header, msgid, header->msgid, header->size);
+               vcos_assert(0);
+            }
          }
       }
    }
@@ -2050,7 +2086,7 @@ vchiq_close_service(VCHIQ_SERVICE_HANDLE_T handle)
    VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *) handle;
    VCHIQ_STATUS_T status = VCHIQ_ERROR;
 
-   if (service == NULL)
+   if (!is_valid_service(service))
       return VCHIQ_ERROR;
 
    vcos_log_info("%d: close_service:%d", service->state->id, service->localport);
@@ -2080,7 +2116,7 @@ vchiq_remove_service(VCHIQ_SERVICE_HANDLE_T handle)
    VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *) handle;
    VCHIQ_STATUS_T status = VCHIQ_SUCCESS;
 
-   if (service == NULL)
+   if (!is_valid_service(service))
       return VCHIQ_ERROR;
 
    vcos_log_info("%d: remove_service:%d", service->state->id, service->localport);
@@ -2137,15 +2173,14 @@ vchiq_bulk_transfer(VCHIQ_SERVICE_T *service,
    const int dir_msgtype = (dir == VCHIQ_BULK_TRANSMIT) ? VCHIQ_MSG_BULK_TX : VCHIQ_MSG_BULK_RX;
    VCHIQ_STATUS_T status = VCHIQ_ERROR;
 
-   if ((service == NULL) ||
-       ((memhandle == VCHI_MEM_HANDLE_INVALID) && (offset == NULL)))
+   if (!is_valid_service(service) ||
+       (service->srvstate != VCHIQ_SRVSTATE_OPEN) ||
+       ((memhandle == VCHI_MEM_HANDLE_INVALID) && (offset == NULL)) ||
+       (vchiq_check_service(service) != VCHIQ_SUCCESS))
       return VCHIQ_ERROR;
 
    state = service->state;
 
-   if (service->srvstate != VCHIQ_SRVSTATE_OPEN)
-      return VCHIQ_ERROR;  /* Must be connected */
-
    if (vcos_mutex_lock(&service->bulk_mutex) != VCOS_SUCCESS)
       return VCHIQ_RETRY;
 
@@ -2325,8 +2360,9 @@ vchiq_queue_message(VCHIQ_SERVICE_HANDLE_T handle,
    unsigned int size = 0;
    unsigned int i;
 
-   if ((service == NULL) ||
-      (service->srvstate != VCHIQ_SRVSTATE_OPEN))
+   if (!is_valid_service(service) ||
+      (service->srvstate != VCHIQ_SRVSTATE_OPEN) ||
+      (vchiq_check_service(service) != VCHIQ_SUCCESS))
       return VCHIQ_ERROR;
 
    for (i = 0; i < (unsigned int)count; i++)
@@ -2361,7 +2397,7 @@ vchiq_release_message(VCHIQ_SERVICE_HANDLE_T handle, VCHIQ_HEADER_T *header)
    int slot_index;
    int msgid;
 
-   if (service == NULL)
+   if (!is_valid_service(service))
       return;
 
    state = service->state;
@@ -2418,7 +2454,7 @@ vchiq_set_service_option(VCHIQ_SERVICE_HANDLE_T handle,
    VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
    VCHIQ_STATUS_T status = VCHIQ_ERROR;
 
-   if (service)
+   if (is_valid_service(service))
    {
       switch (option)
       {
@@ -2427,6 +2463,48 @@ vchiq_set_service_option(VCHIQ_SERVICE_HANDLE_T handle,
          status = VCHIQ_SUCCESS;
          break;
 
+      case VCHIQ_SERVICE_OPTION_SLOT_QUOTA:
+         {
+            VCHIQ_SERVICE_QUOTA_T *service_quota =
+               &service->state->service_quotas[service->localport];
+            if (value == 0)
+               value = service->state->default_slot_quota;
+            if ((value >= service_quota->slot_use_count) &&
+                (value < (unsigned short)~0))
+            {
+               service_quota->slot_quota = value;
+               if ((value >= service_quota->slot_use_count) &&
+                   (service_quota->message_quota >= service_quota->message_use_count))
+               {
+                  /* Signal the service that it may have dropped below its quota */
+                  vcos_event_signal(&service_quota->quota_event);
+               }
+               status = VCHIQ_SUCCESS;
+            }
+         }
+         break;
+
+      case VCHIQ_SERVICE_OPTION_MESSAGE_QUOTA:
+         {
+            VCHIQ_SERVICE_QUOTA_T *service_quota =
+               &service->state->service_quotas[service->localport];
+            if (value == 0)
+               value = service->state->default_message_quota;
+            if ((value >= service_quota->message_use_count) &&
+                (value < (unsigned short)~0))
+            {
+               service_quota->message_quota = value;
+               if ((value >= service_quota->message_use_count) &&
+                   (service_quota->slot_quota >= service_quota->slot_use_count))
+               {
+                  /* Signal the service that it may have dropped below its quota */
+                  vcos_event_signal(&service_quota->quota_event);
+               }
+               status = VCHIQ_SUCCESS;
+            }
+         }
+         break;
+
       default:
          break;
       }
@@ -2568,9 +2646,11 @@ vchiq_dump_service_state(void *dump_context, VCHIQ_SERVICE_T *service)
          vcos_strcpy(remoteport, "n/a");
 
       len += vcos_snprintf(buf + len, sizeof(buf) - len,
-         " '%c%c%c%c' remote %s (slot use %d/%d)",
+         " '%c%c%c%c' remote %s (msg use %d/%d, slot use %d/%d)",
          VCHIQ_FOURCC_AS_4CHARS(fourcc),
          remoteport,
+         service_quota->message_use_count,
+         service_quota->message_quota,
          service_quota->slot_use_count,
          service_quota->slot_quota);
 
@@ -2602,3 +2682,19 @@ vchiq_dump_service_state(void *dump_context, VCHIQ_SERVICE_T *service)
 
    vchiq_dump_platform_service_state(dump_context, service);
 }
+
+
+VCHIQ_STATUS_T vchiq_send_remote_use(VCHIQ_STATE_T * state)
+{
+   return queue_message(state, NULL, VCHIQ_MAKE_MSG(VCHIQ_MSG_REMOTE_USE, 0, 0), NULL, 0, 0, 0);
+}
+
+VCHIQ_STATUS_T vchiq_send_remote_release(VCHIQ_STATE_T * state)
+{
+   return queue_message(state, NULL, VCHIQ_MAKE_MSG(VCHIQ_MSG_REMOTE_RELEASE, 0, 0), NULL, 0, 0, 0);
+}
+
+VCHIQ_STATUS_T vchiq_send_remote_use_active(VCHIQ_STATE_T * state)
+{
+   return queue_message(state, NULL, VCHIQ_MAKE_MSG(VCHIQ_MSG_REMOTE_USE_ACTIVE, 0, 0), NULL, 0, 0, 0);
+}
diff --git a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_core.h b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_core.h
index 641f6a6..8dc8f5c 100644
--- a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_core.h
+++ b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_core.h
@@ -47,6 +47,9 @@ vcos_static_assert(IS_POW2(VCHIQ_MAX_SLOTS_PER_SIDE));
 #define VCHIQ_MSG_BULK_TX_DONE         9  // + (srcport, dstport), actual
 #define VCHIQ_MSG_PAUSE               10  // -
 #define VCHIQ_MSG_RESUME              11  // -
+#define VCHIQ_MSG_REMOTE_USE          12  // -
+#define VCHIQ_MSG_REMOTE_RELEASE      13  // -
+#define VCHIQ_MSG_REMOTE_USE_ACTIVE   14  // -
 
 #define VCHIQ_PORT_MAX                 (VCHIQ_MAX_SERVICES - 1)
 #define VCHIQ_PORT_FREE                0x1000
@@ -194,6 +197,8 @@ typedef struct remote_event_struct {
    VCOS_EVENT_T * event;
 } REMOTE_EVENT_T;
 
+typedef struct opaque_platform_state_t* VCHIQ_PLATFORM_STATE_T;
+
 typedef struct vchiq_state_struct VCHIQ_STATE_T;
 
 typedef struct vchiq_slot_struct {
@@ -253,8 +258,10 @@ typedef struct vchiq_service_struct {
    usage is carried over between users of the same port number.
  */
 typedef struct vchiq_service_quota_struct {
-   int slot_quota;
-   int slot_use_count;
+   unsigned short slot_quota;
+   unsigned short slot_use_count;
+   unsigned short message_quota;
+   unsigned short message_use_count;
    VCOS_EVENT_T quota_event;
    int previous_tx_index;
 } VCHIQ_SERVICE_QUOTA_T;
@@ -314,7 +321,8 @@ struct vchiq_state_struct {
    VCHIQ_SHARED_STATE_T *remote;
    VCHIQ_SLOT_T *slot_data;
 
-   int default_slot_quota;
+   unsigned short default_slot_quota;
+   unsigned short default_message_quota;
 
    VCOS_EVENT_T connect;      // event indicating connect message received
    VCOS_MUTEX_T mutex;        // mutex protecting services
@@ -322,7 +330,6 @@ struct vchiq_state_struct {
 
    VCOS_THREAD_T slot_handler_thread;  // processes incoming messages
    VCOS_THREAD_T recycle_thread;       // processes recycled slots
-   VCOS_THREAD_T lp_thread;            // processes low priority messages (eg suspend)
 
    /* Local implementation of the trigger remote event */
    VCOS_EVENT_T trigger_event;
@@ -330,8 +337,6 @@ struct vchiq_state_struct {
    /* Local implementation of the recycle remote event */
    VCOS_EVENT_T recycle_event;
 
-   VCOS_EVENT_T lp_evt;
-
    char *tx_data;
    char *rx_data;
    VCHIQ_SLOT_INFO_T *rx_info;
@@ -340,17 +345,6 @@ struct vchiq_state_struct {
 
    VCOS_MUTEX_T recycle_mutex;
 
-   VCOS_MUTEX_T suspend_resume_mutex;
-   VCOS_MUTEX_T use_count_mutex;
-
-   /* Global use count for videocore.
-    * This is equal to the sum of the use counts for all services.  When this hits
-    * zero the videocore suspend procedure will be initiated. */
-   int videocore_use_count;
-
-   /* Flag to indicate whether videocore is currently suspended */
-   int videocore_suspended;
-
    /* Indicates the byte position within the stream from where the next message
       will be read. The least significant bits are an index into the slot.
       The next bits are the index of the slot in remote->slot_queue. */
@@ -388,6 +382,8 @@ struct vchiq_state_struct {
    VCHIQ_SERVICE_T *services[VCHIQ_MAX_SERVICES];
    VCHIQ_SERVICE_QUOTA_T service_quotas[VCHIQ_MAX_SERVICES];
    VCHIQ_SLOT_INFO_T slot_info[VCHIQ_MAX_SLOTS];
+
+   VCHIQ_PLATFORM_STATE_T platform_state;
 };
 
 extern VCHIQ_SLOT_ZERO_T *
@@ -477,4 +473,33 @@ extern void
 vchiq_dump_platform_service_state(void *dump_context,
    VCHIQ_SERVICE_T *service);
 
+extern VCHIQ_STATUS_T
+vchiq_use_service_internal(VCHIQ_SERVICE_T *service);
+
+extern VCHIQ_STATUS_T
+vchiq_release_service_internal(VCHIQ_SERVICE_T *service);
+
+extern VCHIQ_STATUS_T
+vchiq_on_remote_use(VCHIQ_STATE_T *state);
+
+extern VCHIQ_STATUS_T
+vchiq_on_remote_release(VCHIQ_STATE_T *state);
+
+extern VCHIQ_STATUS_T
+vchiq_platform_init_state(VCHIQ_STATE_T *state);
+
+extern void
+vchiq_on_remote_use_active(VCHIQ_STATE_T *state);
+
+extern VCHIQ_STATUS_T
+vchiq_send_remote_use(VCHIQ_STATE_T * state);
+
+extern VCHIQ_STATUS_T
+vchiq_send_remote_release(VCHIQ_STATE_T * state);
+
+extern VCHIQ_STATUS_T
+vchiq_send_remote_use_active(VCHIQ_STATE_T * state);
+
+
+
 #endif
diff --git a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_if.h b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_if.h
index af3fa7c..42d471b 100644
--- a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_if.h
+++ b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_if.h
@@ -55,7 +55,9 @@ typedef enum
 
 typedef enum
 {
-   VCHIQ_SERVICE_OPTION_AUTOCLOSE
+   VCHIQ_SERVICE_OPTION_AUTOCLOSE,
+   VCHIQ_SERVICE_OPTION_SLOT_QUOTA,
+   VCHIQ_SERVICE_OPTION_MESSAGE_QUOTA
 } VCHIQ_SERVICE_OPTION_T;
 
 #ifdef __HIGHC__
@@ -94,11 +96,11 @@ typedef struct vchiq_service_base_struct {
 } VCHIQ_SERVICE_BASE_T;
 
 typedef struct vchiq_service_params_struct {
-  int fourcc;
-  VCHIQ_CALLBACK_T callback;
-  void *userdata;
-  short version;       /* Increment for non-trivial changes */
-  short version_min;   /* Update for incompatible changes */
+   int fourcc;
+   VCHIQ_CALLBACK_T callback;
+   void *userdata;
+   short version;       /* Increment for non-trivial changes */
+   short version_min;   /* Update for incompatible changes */
 } VCHIQ_SERVICE_PARAMS_T;
 
 typedef struct vchiq_config_struct {
@@ -112,6 +114,8 @@ typedef struct vchiq_config_struct {
 } VCHIQ_CONFIG_T;
 
 typedef struct vchiq_instance_struct *VCHIQ_INSTANCE_T;
+typedef void (*VCHIQ_REMOTE_USE_CALLBACK_T)(void* cb_arg);
+
 
 extern VCHIQ_STATUS_T vchiq_initialise(VCHIQ_INSTANCE_T *pinstance);
 extern VCHIQ_STATUS_T vchiq_shutdown(VCHIQ_INSTANCE_T instance);
@@ -143,6 +147,9 @@ extern int            vchiq_get_client_id(VCHIQ_SERVICE_HANDLE_T service);
 extern VCHIQ_STATUS_T vchiq_get_config(VCHIQ_INSTANCE_T instance, int config_size, VCHIQ_CONFIG_T *pconfig);
 extern VCHIQ_STATUS_T vchiq_set_service_option(VCHIQ_SERVICE_HANDLE_T service, VCHIQ_SERVICE_OPTION_T option, int value);
 
+extern VCHIQ_STATUS_T vchiq_remote_use(VCHIQ_INSTANCE_T instance, VCHIQ_REMOTE_USE_CALLBACK_T callback, void* cb_arg);
+extern VCHIQ_STATUS_T vchiq_remote_release(VCHIQ_INSTANCE_T instance);
+
 extern VCHIQ_STATUS_T vchiq_dump_phys_mem( VCHIQ_SERVICE_HANDLE_T service, void *ptr, size_t num_bytes );
 
 #endif /* VCHIQ_IF_H */
diff --git a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_lib.c b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_lib.c
index dd1723d..f1a8f42 100644
--- a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_lib.c
+++ b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_lib.c
@@ -97,6 +97,12 @@ is_valid_instance(VCHIQ_INSTANCE_T instance)
    return (instance == &vchiq_instance) && (instance->initialised > 0);
 }
 
+static __inline int
+is_valid_service(VCHIQ_SERVICE_T *service)
+{
+   return ((service != NULL) && (service->fd != VCHIQ_INVALID_HANDLE));
+}
+
 /*
  * VCHIQ API
  */
@@ -318,6 +324,9 @@ vchiq_close_service(VCHIQ_SERVICE_HANDLE_T handle)
 
    vcos_log_trace( "%s called service handle = 0x%08x", __func__, (uint32_t)handle );
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    RETRY(ret,ioctl(service->fd, VCHIQ_IOC_CLOSE_SERVICE, service->handle));
 
    if (ret != 0)
@@ -335,6 +344,9 @@ vchiq_remove_service(VCHIQ_SERVICE_HANDLE_T handle)
 
    vcos_log_trace( "%s called service handle = 0x%08x", __func__, (uint32_t)handle );
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    RETRY(ret,ioctl(service->fd, VCHIQ_IOC_REMOVE_SERVICE, service->handle));
 
    if (ret != 0)
@@ -355,6 +367,9 @@ vchiq_queue_message(VCHIQ_SERVICE_HANDLE_T handle,
 
    vcos_log_trace( "%s called service handle = 0x%08x", __func__, (uint32_t)handle );
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    args.handle = service->handle;
    args.elements = elements;
    args.count = count;
@@ -384,6 +399,9 @@ vchiq_queue_bulk_transmit(VCHIQ_SERVICE_HANDLE_T handle,
 
    vcos_log_trace( "%s called service handle = 0x%08x", __func__, (uint32_t)handle );
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    args.handle = service->handle;
    args.data = (void *)data;
    args.size = size;
@@ -406,6 +424,9 @@ vchiq_queue_bulk_receive(VCHIQ_SERVICE_HANDLE_T handle,
 
    vcos_log_trace( "%s called service handle = 0x%08x", __func__, (uint32_t)handle );
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    args.handle = service->handle;
    args.data = data;
    args.size = size;
@@ -457,6 +478,9 @@ vchiq_bulk_transmit(VCHIQ_SERVICE_HANDLE_T handle,
 
    vcos_log_trace( "%s called service handle = 0x%08x", __func__, (uint32_t)handle );
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    args.handle = service->handle;
    args.data = (void *)data;
    args.size = size;
@@ -480,6 +504,9 @@ vchiq_bulk_receive(VCHIQ_SERVICE_HANDLE_T handle,
 
    vcos_log_trace( "%s called service handle = 0x%08x", __func__, (uint32_t)handle );
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    args.handle = service->handle;
    args.data = data;
    args.size = size;
@@ -521,6 +548,9 @@ vchiq_get_client_id(VCHIQ_SERVICE_HANDLE_T handle)
 {
    VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    return ioctl(service->fd, VCHIQ_IOC_GET_CLIENT_ID, service->handle);
 }
 
@@ -546,10 +576,14 @@ vchiq_get_config(VCHIQ_INSTANCE_T instance,
 int32_t
 vchiq_use_service( const VCHIQ_SERVICE_HANDLE_T handle )
 {
-    VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
-    int ret;
-    RETRY(ret,ioctl(service->fd, VCHIQ_IOC_USE_SERVICE, service->handle));
-    return ret;
+   VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
+   int ret;
+
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
+   RETRY(ret,ioctl(service->fd, VCHIQ_IOC_USE_SERVICE, service->handle));
+   return ret;
 }
 
 int32_t
@@ -569,6 +603,9 @@ vchiq_set_service_option(VCHIQ_SERVICE_HANDLE_T handle,
    VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
    int ret;
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    args.handle = service->handle;
    args.option = option;
    args.value  = value;
@@ -633,6 +670,9 @@ vchi_msg_peek( VCHI_SERVICE_HANDLE_T handle,
    VCHI_SERVICE_T *service = (VCHI_SERVICE_T *)handle;
    int ret;
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    ret = fill_peek_buf(service, flags);
 
    if (ret == 0)
@@ -659,6 +699,9 @@ vchi_msg_remove( VCHI_SERVICE_HANDLE_T handle )
 {
    VCHI_SERVICE_T *service = (VCHI_SERVICE_T *)handle;
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    /* Why would you call vchi_msg_remove without calling vchi_msg_peek first? */
    vcos_assert(service->peek_size >= 0);
 
@@ -697,6 +740,9 @@ vchi_msg_queue( VCHI_SERVICE_HANDLE_T handle,
    vcos_unused(msg_handle);
    vcos_assert(flags == VCHI_FLAGS_BLOCK_UNTIL_QUEUED);
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    args.handle = service->handle;
    args.elements = &element;
    args.count = 1;
@@ -730,6 +776,9 @@ vchi_bulk_queue_receive( VCHI_SERVICE_HANDLE_T handle,
    VCHIQ_QUEUE_BULK_TRANSFER_T args;
    int ret;
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    switch ((int)flags) {
    case VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE | VCHI_FLAGS_BLOCK_UNTIL_QUEUED:
       args.mode = VCHIQ_BULK_MODE_CALLBACK;
@@ -780,6 +829,9 @@ vchi_bulk_queue_transmit( VCHI_SERVICE_HANDLE_T handle,
    VCHIQ_QUEUE_BULK_TRANSFER_T args;
    int ret;
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    switch ((int)flags) {
    case VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE | VCHI_FLAGS_BLOCK_UNTIL_QUEUED:
       args.mode = VCHIQ_BULK_MODE_CALLBACK;
@@ -833,6 +885,9 @@ vchi_msg_dequeue( VCHI_SERVICE_HANDLE_T handle,
 
    vcos_assert(flags == VCHI_FLAGS_NONE || flags == VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE);
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    if (service->peek_size >= 0)
    {
       fprintf(stderr, "vchi_msg_dequeue -> using peek buffer\n");
@@ -903,6 +958,9 @@ vchi_msg_queuev( VCHI_SERVICE_HANDLE_T handle,
 
    vcos_assert(flags == VCHI_FLAGS_BLOCK_UNTIL_QUEUED);
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    args.handle = service->handle;
    args.elements = (const VCHIQ_ELEMENT_T *)vector;
    args.count = count;
@@ -961,6 +1019,9 @@ vchi_msg_hold( VCHI_SERVICE_HANDLE_T handle,
    VCHI_SERVICE_T *service = (VCHI_SERVICE_T *)handle;
    int ret;
 
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    ret = fill_peek_buf(service, flags);
 
    if (ret == 0)
@@ -1116,6 +1177,10 @@ vchi_service_close( const VCHI_SERVICE_HANDLE_T handle )
 {
    VCHI_SERVICE_T *service = (VCHI_SERVICE_T *)handle;
    int ret;
+
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    RETRY(ret,ioctl(service->fd, VCHIQ_IOC_REMOVE_SERVICE, service->handle));
 
    if (ret == 0)
@@ -1129,6 +1194,10 @@ vchi_service_destroy( const VCHI_SERVICE_HANDLE_T handle )
 {
    VCHI_SERVICE_T *service = (VCHI_SERVICE_T *)handle;
    int ret;
+
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    RETRY(ret,ioctl(service->fd, VCHIQ_IOC_REMOVE_SERVICE, service->handle));
 
    if (ret == 0)
@@ -1200,6 +1269,10 @@ vchi_service_use( const VCHI_SERVICE_HANDLE_T handle )
 {
    VCHI_SERVICE_T *service = (VCHI_SERVICE_T *)handle;
    int ret;
+
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    RETRY(ret,ioctl(service->fd, VCHIQ_IOC_USE_SERVICE, service->handle));
    return ret;
 }
@@ -1218,10 +1291,47 @@ int32_t vchi_service_release( const VCHI_SERVICE_HANDLE_T handle )
 {
    VCHI_SERVICE_T *service = (VCHI_SERVICE_T *)handle;
    int ret;
+
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
    RETRY(ret,ioctl(service->fd, VCHIQ_IOC_RELEASE_SERVICE, service->handle));
    return ret;
 }
 
+/***********************************************************
+ * Name: vchiq_dump_phys_mem
+ *
+ * Arguments: const VCHI_SERVICE_HANDLE_T handle
+ *            void *buffer
+ *            size_t num_bytes
+ *
+ * Description: Dumps the physical memory associated with
+ *              a buffer.
+ *
+ * Returns: void
+ *
+ ***********************************************************/
+VCHIQ_STATUS_T vchiq_dump_phys_mem( VCHIQ_SERVICE_HANDLE_T handle,
+                             void *ptr,
+                             size_t num_bytes )
+{
+   VCHIQ_SERVICE_T *service = (VCHIQ_SERVICE_T *)handle;
+   VCHIQ_DUMP_MEM_T  dump_mem;
+   int ret;
+
+   if (!is_valid_service(service))
+      return VCHIQ_ERROR;
+
+   dump_mem.virt_addr = ptr;
+   dump_mem.num_bytes = num_bytes;
+
+   RETRY(ret,ioctl(service->fd, VCHIQ_IOC_DUMP_PHYS_MEM, &dump_mem));
+   return (ret >= 0) ? VCHIQ_SUCCESS : VCHIQ_ERROR;
+}
+
+
+
 /*
  * Support functions
  */
diff --git a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_shim.c b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_shim.c
index 29aa23f..88cd86f 100644
--- a/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_shim.c
+++ b/drivers/misc/vc04_services/interface/vchiq_arm/vchiq_shim.c
@@ -859,10 +859,38 @@ int32_t vchi_service_create( VCHI_INSTANCE_T instance_handle,
 
 int32_t vchi_service_close( const VCHI_SERVICE_HANDLE_T handle )
 {
-   vcos_unused(handle);
+   int32_t ret = -1;
+   SHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;
+   if(service)
+   {
+      VCHIQ_STATUS_T status = vchiq_close_service(service->handle);
+      if (status == VCHIQ_SUCCESS)
+      {
+         service_free(service);
+         service = NULL;
+      }
 
-   // YTI??
-   return 0;
+      ret = vchiq_status_to_vchi( status );
+   }
+   return ret;
+}
+
+int32_t vchi_service_destroy( const VCHI_SERVICE_HANDLE_T handle )
+{
+   int32_t ret = -1;
+   SHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;
+   if(service)
+   {
+      VCHIQ_STATUS_T status = vchiq_remove_service(service->handle);
+      if (status == VCHIQ_SUCCESS)
+      {
+         service_free(service);
+         service = NULL;
+      }
+
+      ret = vchiq_status_to_vchi( status );
+   }
+   return ret;
 }
 
 /* ----------------------------------------------------------------------
@@ -962,9 +990,12 @@ EXPORT_SYMBOL(vchi_bulk_queue_transmit);
 EXPORT_SYMBOL(vchi_msg_dequeue);
 EXPORT_SYMBOL(vchi_msg_queue);
 EXPORT_SYMBOL(vchi_msg_queuev);
+EXPORT_SYMBOL(vchi_msg_peek);
+EXPORT_SYMBOL(vchi_msg_remove);
 EXPORT_SYMBOL(vchi_service_close);
 EXPORT_SYMBOL(vchi_service_open);
 EXPORT_SYMBOL(vchi_service_create);
+EXPORT_SYMBOL(vchi_service_destroy);
 EXPORT_SYMBOL(vchi_service_use);
 EXPORT_SYMBOL(vchi_service_release);
 #endif
-- 
1.7.0.4

