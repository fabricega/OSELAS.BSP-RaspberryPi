diff --git a/gfxdrivers/gles2/gles2_2d.c b/gfxdrivers/gles2/gles2_2d.c
index 4a6fd3e..08eb228 100644
--- a/gfxdrivers/gles2/gles2_2d.c
+++ b/gfxdrivers/gles2/gles2_2d.c
@@ -37,6 +37,8 @@
 
 #include <core/state.h>
 #include <core/surface.h>
+#include <core/surface_allocation.h>
+#include <core/surface_pool.h>
 #include <core/system.h>
 
 #include <gfx/convert.h>
@@ -56,25 +58,26 @@ D_DEBUG_DOMAIN( GL, "GL", "GL" );
  * There's no prefix because of the macros below.
  */
 enum {
-     DESTINATION  = 0x00000001,
-     SCISSOR      = 0x00000002,
-     MATRIX       = 0x00000004,
-     RENDER_OPTS  = 0x00000008,
+     DESTINATION     = 0x00000001,
+     SCISSOR         = 0x00000002,
+     MATRIX          = 0x00000004,
+     RENDER_OPTS     = 0x00000008,
 
-     COLOR_DRAW   = 0x00000010,
-     COLORKEY     = 0x00000020,
+     COLOR_DRAW      = 0x00000010,
+     COLORKEY        = 0x00000020,
 
-     SOURCE       = 0x00000100,
-     COLOR_BLIT   = 0x00000200,
+     SOURCE          = 0x00000100,
+     COLOR_BLIT      = 0x00000200,
+     SRC_CONVOLUTION = 0x00000400,
 
-     BLENDFUNC    = 0x00010000,
+     BLENDFUNC       = 0x00010000,
 
-     ALL          = 0x0001033F
+     ALL             = 0x0001073F
 };
 
 /*
  * State handling macros.  Shader uniform variables are shader program state
- * and some of them are duplicated across programs.  
+ * and some of them are duplicated across programs.
  */
 #define GLES2_VALIDATE(flags)        \
      do {			     \
@@ -98,11 +101,71 @@ enum {
 
 /*****************************************************************************/
 
+static void
+enterMode( GLES2DriverData *gdrv,
+           GLES2DeviceData *gdev,
+           EngineMode       mode )
+{
+#ifdef DIRECTFB_GLES2_PVR2D
+     PVR2DERROR ePVR2DStatus;
+#endif
+
+//     D_INFO("enterMode %d (current %d, calls %d)\n", mode,gdrv->engine_mode,gdrv->calls);
+     if (gdrv->engine_mode == mode)
+          return;
+
+     switch (gdrv->engine_mode) {
+          case MODE_IDLE:
+               break;
+
+          case MODE_GLES2:
+               if (gdrv->calls > 0) {
+//                    glFlush();
+
+//                    long long t1=direct_clock_get_abs_millis();
+                    if (mode == MODE_IDLE) {
+                         //glFinish();
+#ifdef DIRECTFB_GLES2_PVR2D
+                         eglSwapBuffers( eglGetCurrentDisplay(), eglGetCurrentSurface( EGL_DRAW ) );
+#endif
+                    }
+//                    long long t2=direct_clock_get_abs_millis();
+//                    D_INFO("GL sync took %lld ms\n", t2-t1);
+
+                    gdrv->calls = 0;
+               }
+               break;
+
+          case MODE_PVR2D: {
+#ifdef DIRECTFB_GLES2_PVR2D
+//               long long t1=direct_clock_get_abs_millis();
+               if (gdrv->pvr2d_dest) {
+                    //long long t1=direct_clock_get_abs_millis();
+                    ePVR2DStatus = PVR2DQueryBlitsComplete( gdrv->hPVR2DContext, gdrv->pvr2d_dest, PVR2D_TRUE );
+                    if (ePVR2DStatus) {
+                         D_ERROR( "DirectFB/PVR2D: PVR2DQueryBlitsComplete() failed! (status %d)\n", ePVR2DStatus );
+               //          return false;
+                    }
+                    //usleep(6000);
+                   // D_INFO("queryblits %lld\n", direct_clock_get_abs_millis()-t1);
+               }
+//               long long t2=direct_clock_get_abs_millis();
+//               D_INFO("PVR2D sync took %lld ms\n", t2-t1);
+#endif
+               break;
+          }
+     }
+
+     gdrv->engine_mode = mode;
+}
+
+/*****************************************************************************/
+
 /*
  * Called by gles2SetState() to ensure that the rendering options are properly
  * set for execution of rendering functions.
  *
- * XXX hood - TODO 
+ * XXX hood - TODO
  * Line anti-aliasing is not directly supported in GLES2.  A shader for it
  * needs to be written.  Could use multisample buffers as well to cover
  * all point, line, and triangle primitives.
@@ -212,6 +275,16 @@ gles2_validate_DESTINATION(GLES2DriverData *gdrv,
                m[1] =    0.0; m[4] = -2.0f/h; m[7] =  1.0f;
                m[2] =    0.0; m[5] =     0.0; m[8] =  1.0f;
 
+               int fbo;
+
+               glGetIntegerv( GL_FRAMEBUFFER_BINDING, &fbo );
+
+               // Just need the X & Y scale factors and constant offsets.
+               if (fbo) {
+                    m[4] = 2.0f/h;
+                    m[7] = - 1.0f;
+               }
+
                // Load it in the proper location for this program object.
                glUniformMatrix3fv(prog->dfbMVPMatrix, 1, GL_FALSE, m);
 
@@ -234,10 +307,40 @@ gles2_validate_DESTINATION(GLES2DriverData *gdrv,
                           2.0f/w, 2.0f/h);
           }
 
-//          GLES2_INVALIDATE(ALL);
+          GLES2_INVALIDATE(ALL);
 //          buffer->flags &= ~GLES2BF_UPDATE_TARGET;
      }
 
+#ifdef DIRECTFB_GLES2_PVR2D
+     if (!strcmp( state->dst.allocation->pool->desc.name, "PVR2D Pool" )) {
+//          D_INFO("GLES2: PVR2D Destination (%dx%d)\n", state->dst.allocation->config.size.w, state->dst.allocation->config.size.h );
+
+          gdrv->bltinfo.pDstMemInfo   = state->dst.handle;
+          gdrv->bltinfo.DstOffset     = 0;
+          gdrv->bltinfo.DstStride     = state->dst.pitch;
+          gdrv->bltinfo.DstSurfWidth  = state->destination->config.size.w;
+          gdrv->bltinfo.DstSurfHeight = state->destination->config.size.h;
+
+          switch (state->destination->config.format) {
+               case DSPF_ARGB:
+               case DSPF_RGB32:
+                    gdrv->bltinfo.DstFormat = PVR2D_ARGB8888;
+                    break;
+
+               case DSPF_RGB16:
+                    gdrv->bltinfo.DstFormat = PVR2D_RGB565;
+                    break;
+
+               default:
+                    D_BUG( "unexpected pixelformat %d", state->destination->config.format );
+          }
+
+          gdrv->pvr2d_dest = state->dst.handle;
+     }
+     else
+          gdrv->pvr2d_dest = NULL;
+#endif
+
      // Set the flag.
      GLES2_VALIDATE(DESTINATION);
 }
@@ -258,7 +361,7 @@ gles2_validate_MATRIX(GLES2DriverData *gdrv,
            * We have to load a new surface render options matrix.  The matrix
            * is 3x3 with row major ordering, and it can encode non-affine 2D
            * transforms.  The elements are s32, 16.16 fixed point format.
-           */ 
+           */
           float m[9];
           GLES2ProgramInfo *prog = &gdev->progs[gdev->prog_index];
 
@@ -321,6 +424,10 @@ gles2_validate_COLOR_DRAW(GLES2DriverData *gdrv,
                      state->color.b * s, state->color.a * s);
      }
 
+#ifdef DIRECTFB_GLES2_PVR2D
+     gdrv->bltinfo.Colour = PIXEL_ARGB( state->color.a, state->color.r, state->color.g, state->color.b );
+#endif
+
      // Set the flag.
      GLES2_VALIDATE(COLOR_DRAW);
 }
@@ -344,37 +451,122 @@ gles2_validate_SOURCE(GLES2DriverData *gdrv,
 
      D_DEBUG_AT( GL, "%s glBindTexture (%d)\n", __FUNCTION__, texture );
 
-     glBindTexture( GL_TEXTURE_2D, texture );
+#ifdef DIRECTFB_GLES2_PVR2D
+     if (!strcmp( state->src.allocation->pool->desc.name, "PVR2D Pool" )) {
+//          D_INFO("GLES2: PVR2D Source (%dx%d)\n", state->src.allocation->config.size.w, state->src.allocation->config.size.h );
 
-     if (1/*(buffer->flags & GLES2BF_UPDATE_TEXTURE)*/ ||
-         (gdev->prog_index != gdev->prog_last)) {
+          gdrv->bltinfo.pSrcMemInfo   = state->src.handle;
+          gdrv->bltinfo.SrcOffset     = 0;
+          gdrv->bltinfo.SrcStride     = state->src.pitch;
+          gdrv->bltinfo.SrcSurfWidth  = state->source->config.size.w;
+          gdrv->bltinfo.SrcSurfHeight = state->source->config.size.h;
 
-          int w = surface->config.size.w;
-          int h = surface->config.size.h;
+          switch (state->source->config.format) {
+               case DSPF_A8:
+                    gdrv->bltinfo.SrcFormat = PVR2D_ALPHA8;
+                    break;
 
-          D_DEBUG_AT(GLES2__2D, "  -> got new prog or texture %d\n", texture);
-          D_DEBUG_AT(GLES2__2D, "  -> old prog \"%s\" new prog \"%s\"\n",
-                     gdev->progs[gdev->prog_last].name,
-                     gdev->progs[gdev->prog_index].name);
+               case DSPF_ARGB:
+               case DSPF_RGB32:
+                    gdrv->bltinfo.SrcFormat = PVR2D_ARGB8888;
+                    break;
 
-          /*
-           * The equivalent of ARB_texture_rectangle isn't supported by GLES2,
-           * so blit source coordinates have to be normalized to tex coords in
-           * the range [0..1].
-           */
-          glUniform2f(prog->dfbTexScale, 1.0f/w, 1.0f/h);
+               case DSPF_RGB16:
+                    gdrv->bltinfo.SrcFormat = PVR2D_RGB565;
+                    break;
 
-          D_DEBUG_AT(GLES2__2D, "  -> w %d h %d, scale x %f scale y %f\n",
-                     w, h, 1.0f/w, 1.0f/h);
+               default:
+                    D_BUG( "unexpected pixelformat %d", state->source->config.format );
+          }
 
-//          buffer->flags &= ~GLES2BF_UPDATE_TEXTURE;
+          gdrv->pvr2d_source = state->src.handle;
      }
+     else {
+          gdrv->pvr2d_source = NULL;
+#endif
+
+          glBindTexture( GL_TEXTURE_2D, texture );
+
+          if ((1/*(buffer->flags & GLES2BF_UPDATE_TEXTURE)*/ ||
+              (gdev->prog_index != gdev->prog_last)) && gdev->prog_index < GLES2_TEXTRI) {
+
+               int w = surface->config.size.w;
+               int h = surface->config.size.h;
+
+               D_DEBUG_AT(GLES2__2D, "  -> got new prog or texture %d\n", texture);
+               D_DEBUG_AT(GLES2__2D, "  -> old prog \"%s\" new prog \"%s\"\n",
+                          gdev->progs[gdev->prog_last].name,
+                          gdev->progs[gdev->prog_index].name);
+
+               /*
+                * The equivalent of ARB_texture_rectangle isn't supported by GLES2,
+                * so blit source coordinates have to be normalized to tex coords in
+                * the range [0..1].
+                */
+               glUniform2f(prog->dfbTexScale, 1.0f/w, 1.0f/h);
+
+               D_DEBUG_AT(GLES2__2D, "  -> w %d h %d, scale x %f scale y %f\n",
+                          w, h, 1.0f/w, 1.0f/h);
+
+     //          buffer->flags &= ~GLES2BF_UPDATE_TEXTURE;
+          }
+#ifdef DIRECTFB_GLES2_PVR2D
+     }
+#endif
 
      // Set the flag.
      GLES2_VALIDATE(SOURCE);
 }
 
 /*
+ * Called by gles2SetState() to ensure that the source parameters are properly
+ * set for execution of blitting functions.  gdev->prog_index must be valid.
+ */
+static inline void
+gles2_validate_SRC_CONVOLUTION(GLES2DriverData *gdrv,
+                               GLES2DeviceData *gdev,
+                               CardState       *state)
+{
+     GLES2ProgramInfo *prog = &gdev->progs[gdev->prog_index];
+
+     D_DEBUG_AT(GLES2__2D, "%s()\n", __FUNCTION__, texture);
+
+     if (0&&gdev->prog_index == GLES2_BLIT) {
+          if (state->blittingflags & DSBLIT_SRC_CONVOLUTION) {
+               float filter[11] = {
+                    state->src_convolution.kernel[0] * (1.0f/65536.0f),
+                    state->src_convolution.kernel[1] * (1.0f/65536.0f),
+                    state->src_convolution.kernel[2] * (1.0f/65536.0f),
+                    state->src_convolution.kernel[3] * (1.0f/65536.0f),
+                    state->src_convolution.kernel[4] * (1.0f/65536.0f),
+                    state->src_convolution.kernel[5] * (1.0f/65536.0f),
+                    state->src_convolution.kernel[6] * (1.0f/65536.0f),
+                    state->src_convolution.kernel[7] * (1.0f/65536.0f),
+                    state->src_convolution.kernel[8] * (1.0f/65536.0f),
+
+                    state->src_convolution.scale * (1.0f/65536.0f), state->src_convolution.bias * (1.0f/65536.0f)
+               };
+
+               glUniform1fv( prog->dfbConvFilter, 11, filter );
+          }
+          else {
+               static const float no_filter[11] = {
+                    0.0f, 0.0f, 0.0f,
+                    0.0f, 0.0f, 0.0f,
+                    0.0f, 0.0f, 0.0f,
+
+                    0.0f, 0.0f
+               };
+
+               glUniform1fv( prog->dfbConvFilter, 11, no_filter );
+          }
+     }
+
+     // Set the flag.
+     GLES2_VALIDATE(SRC_CONVOLUTION);
+}
+
+/*
  * Called by gles2SetState() to ensure that the color is properly set
  * for execution of blitting functions.  gdev->prog_index must be valid.
  */
@@ -425,6 +617,10 @@ gles2_validate_COLOR_BLIT(GLES2DriverData *gdrv,
      glUniform4f(prog->dfbColor, r, g, b, a);
      D_DEBUG_AT(GLES2__2D, "  -> loaded color %f %f %f %f\n", r, g, b, a);
 
+#ifdef DIRECTFB_GLES2_PVR2D
+     gdrv->bltinfo.Colour = PIXEL_ARGB( state->color.a, state->color.r, state->color.g, state->color.b );
+#endif
+
      // Set the flag.
      GLES2_VALIDATE(COLOR_BLIT);
 }
@@ -568,6 +764,10 @@ gles2_validate_BLENDFUNC(GLES2DriverData *gdrv,
 
      glBlendFunc(src, dst);
 
+#ifdef DIRECTFB_GLES2_PVR2D
+     gdrv->bltinfo.AlphaBlendingFunc = (state->src_blend != DSBF_SRCALPHA) ? PVR2D_ALPHA_OP_SRC_DSTINV : PVR2D_ALPHA_OP_SRCP_DSTINV;
+#endif
+
      // Set the flag.
      GLES2_VALIDATE(BLENDFUNC);
 }
@@ -586,15 +786,9 @@ gles2_validate_BLENDFUNC(GLES2DriverData *gdrv,
 DFBResult
 gles2EngineSync(void *drv, void *dev)
 {
-     GLES2DriverData *gdrv = drv;
-
      D_DEBUG_AT(GLES2__2D, "%s()\n", __FUNCTION__);
 
-     if (gdrv->calls > 0) {
-//          glFinish();
-          //eglSwapBuffers( eglGetCurrentDisplay(), eglGetCurrentSurface( EGL_DRAW ) );
-          gdrv->calls = 0;
-     }
+     enterMode( drv, dev, MODE_IDLE );
 
      return DFB_OK;
 }
@@ -668,12 +862,24 @@ gles2CheckState(void                *drv,
           }
      }
      else {
+          switch (state->source->config.format) {
+               case DSPF_ARGB:
+               case DSPF_ABGR:
+                    break;
+
+               default:
+                    return;
+          }
+
           // Return if unsupported blitting flags are set.
           if (blittingflags & ~GLES2_SUPPORTED_BLITTINGFLAGS) {
                D_DEBUG_AT(GLES2__2D, "  -> unsupported blit flags 0x%08x\n",
                           blittingflags);
                return;
           }
+
+          if (accel == DFXL_TEXTRIANGLES && (state->render_options & DSRO_MATRIX))
+               return;
      }
 
      // Enable acceleration of the function.
@@ -728,10 +934,10 @@ gles2SetState(void                *drv,
                GLES2_INVALIDATE(COLOR_DRAW | COLOR_BLIT);
 
           if (modified & SMF_DRAWING_FLAGS)
-               GLES2_INVALIDATE(COLOR_DRAW);
+               GLES2_INVALIDATE(COLOR_DRAW | BLENDFUNC);
 
           if (modified & SMF_BLITTING_FLAGS)
-               GLES2_INVALIDATE(COLOR_BLIT);
+               GLES2_INVALIDATE(COLOR_BLIT | BLENDFUNC | SRC_CONVOLUTION);
 
           if (modified & SMF_SOURCE)
                GLES2_INVALIDATE(SOURCE);
@@ -741,6 +947,9 @@ gles2SetState(void                *drv,
 
           if (modified & SMF_SRC_COLORKEY)
                GLES2_INVALIDATE(COLORKEY);
+
+          if (modified & SMF_SRC_CONVOLUTION)
+               GLES2_INVALIDATE(SRC_CONVOLUTION);
      }
 
      /*
@@ -756,21 +965,6 @@ gles2SetState(void                *drv,
           case DFXL_DRAWRECTANGLE:
           case DFXL_DRAWLINE:
           case DFXL_FILLTRIANGLE:
-               // FIXME: workaround state issue in some drivers?
-               glBlendFunc(GL_ZERO, GL_ZERO);
-               GLES2_INVALIDATE(BLENDFUNC);
-
-               // If alpha blending is used...
-               if (state->drawingflags & DSDRAW_BLEND) {
-                    // ...require valid blend functions.
-                    GLES2_CHECK_VALIDATE(BLENDFUNC);
-                    glEnable(GL_BLEND);
-               }
-               else {
-                    glBlendFunc(GL_ONE, GL_ZERO);
-                    glDisable(GL_BLEND);
-               }
-
                /*
                 * Validate the current shader program.  This can't use the the
                 * GLES2_CHECK_VALIDATE macro since the needed state isn't
@@ -800,6 +994,16 @@ gles2SetState(void                *drv,
                // Check for valid drawing color.
                GLES2_CHECK_VALIDATE(COLOR_DRAW);
 
+               // If alpha blending is used...
+               if (state->drawingflags & DSDRAW_BLEND) {
+                    // ...require valid blend functions.
+                    GLES2_CHECK_VALIDATE(BLENDFUNC);
+                    glEnable(GL_BLEND);
+               }
+               else {
+                    glBlendFunc(GL_ONE, GL_ZERO);
+                    glDisable(GL_BLEND);
+               }
 
                // Enable vertex positions and disable texture coordinates.
                glEnableVertexAttribArray(GLES2VA_POSITIONS);
@@ -817,21 +1021,12 @@ gles2SetState(void                *drv,
 
           case DFXL_BLIT:
           case DFXL_STRETCHBLIT:
-               // FIXME: workaround state issue in some drivers?
-               glBlendFunc(GL_ZERO, GL_ZERO);
-               GLES2_INVALIDATE(BLENDFUNC);
-
+          case DFXL_TEXTRIANGLES:
                // If alpha blending is used...
-               if (state->blittingflags & (DSBLIT_BLEND_ALPHACHANNEL |
-                                           DSBLIT_BLEND_COLORALPHA)) {
-                    // ...require valid blend functions.
-                    GLES2_CHECK_VALIDATE(BLENDFUNC);
-                    glEnable(GL_BLEND);
+               if (state->blittingflags & (DSBLIT_BLEND_ALPHACHANNEL | DSBLIT_BLEND_COLORALPHA)) {
                     blend = DFB_TRUE;
                }
                else {
-                    glBlendFunc(GL_ONE, GL_ZERO);
-                    glDisable(GL_BLEND);
                     blend = DFB_FALSE;
                }
 
@@ -840,69 +1035,83 @@ gles2SetState(void                *drv,
                 * GLES2_CHECK_VALIDATE macro since the needed state isn't
                 * tracked by DFB.
                 */
-               if (state->render_options & DSRO_MATRIX) {
+               if (accel == DFXL_TEXTRIANGLES) {
                     if (state->blittingflags & DSBLIT_SRC_COLORKEY && !blend) {
-                         if (gdev->prog_index != GLES2_BLIT_COLORKEY_MAT) {
-
-                              gdev->prog_index = GLES2_BLIT_COLORKEY_MAT;
+                         if (gdev->prog_index != GLES2_TEXTRI_COLORKEY) {
+                              gdev->prog_index = GLES2_TEXTRI_COLORKEY;
                               glUseProgram(gdev->progs[gdev->prog_index].obj);
-
-                              glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-                              glEnable(GL_BLEND);
                          }
                     }
                     else if (state->blittingflags & DSBLIT_SRC_PREMULTIPLY) {
-                         if (gdev->prog_index != GLES2_BLIT_PREMULTIPLY_MAT) {
-
-                              gdev->prog_index = GLES2_BLIT_PREMULTIPLY_MAT;
+                         if (gdev->prog_index != GLES2_TEXTRI_PREMULTIPLY) {
+                              gdev->prog_index = GLES2_TEXTRI_PREMULTIPLY;
                               glUseProgram(gdev->progs[gdev->prog_index].obj);
                          }
                     }
                     else if (state->blittingflags & (DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA | DSBLIT_SRC_PREMULTCOLOR)) {
-                         if (gdev->prog_index != GLES2_BLIT_COLOR_MAT) {
-
-                              gdev->prog_index = GLES2_BLIT_COLOR_MAT;
+                         if (gdev->prog_index != GLES2_TEXTRI_COLOR) {
+                              gdev->prog_index = GLES2_TEXTRI_COLOR;
                               glUseProgram(gdev->progs[gdev->prog_index].obj);
                          }
                     }
                     else {
-                         if (gdev->prog_index != GLES2_BLIT_MAT) {
-
-                              gdev->prog_index = GLES2_BLIT_MAT;
+                         if (gdev->prog_index != GLES2_TEXTRI) {
+                              gdev->prog_index = GLES2_TEXTRI;
                               glUseProgram(gdev->progs[gdev->prog_index].obj);
                          }
                     }
                }
                else {
-                    if (state->blittingflags & DSBLIT_SRC_COLORKEY && !blend) {
-                         if (gdev->prog_index != GLES2_BLIT_COLORKEY) {
-
-                              gdev->prog_index = GLES2_BLIT_COLORKEY;
-                              glUseProgram(gdev->progs[gdev->prog_index].obj);
-
-                              glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-                              glEnable(GL_BLEND);
+                    if (state->render_options & DSRO_MATRIX) {
+                         if (state->blittingflags & DSBLIT_SRC_COLORKEY && !blend) {
+                              if (gdev->prog_index != GLES2_BLIT_COLORKEY_MAT) {
+                                   gdev->prog_index = GLES2_BLIT_COLORKEY_MAT;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
                          }
-                    }
-                    else if (state->blittingflags & DSBLIT_SRC_PREMULTIPLY) {
-                         if (gdev->prog_index != GLES2_BLIT_PREMULTIPLY) {
-
-                              gdev->prog_index = GLES2_BLIT_PREMULTIPLY;
-                              glUseProgram(gdev->progs[gdev->prog_index].obj);
+                         else if (state->blittingflags & DSBLIT_SRC_PREMULTIPLY) {
+                              if (gdev->prog_index != GLES2_BLIT_PREMULTIPLY_MAT) {
+                                   gdev->prog_index = GLES2_BLIT_PREMULTIPLY_MAT;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
                          }
-                    }
-                    else if (state->blittingflags & (DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA | DSBLIT_SRC_PREMULTCOLOR)) {
-                         if (gdev->prog_index != GLES2_BLIT_COLOR) {
-
-                              gdev->prog_index = GLES2_BLIT_COLOR;
-                              glUseProgram(gdev->progs[gdev->prog_index].obj);
+                         else if (state->blittingflags & (DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA | DSBLIT_SRC_PREMULTCOLOR)) {
+                              if (gdev->prog_index != GLES2_BLIT_COLOR_MAT) {
+                                   gdev->prog_index = GLES2_BLIT_COLOR_MAT;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
+                         }
+                         else {
+                              if (gdev->prog_index != GLES2_BLIT_MAT) {
+                                   gdev->prog_index = GLES2_BLIT_MAT;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
                          }
                     }
                     else {
-                         if (gdev->prog_index != GLES2_BLIT) {
-
-                              gdev->prog_index = GLES2_BLIT;
-                              glUseProgram(gdev->progs[gdev->prog_index].obj);
+                         if (state->blittingflags & DSBLIT_SRC_COLORKEY && !blend) {
+                              if (gdev->prog_index != GLES2_BLIT_COLORKEY) {
+                                   gdev->prog_index = GLES2_BLIT_COLORKEY;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
+                         }
+                         else if (state->blittingflags & DSBLIT_SRC_PREMULTIPLY) {
+                              if (gdev->prog_index != GLES2_BLIT_PREMULTIPLY) {
+                                   gdev->prog_index = GLES2_BLIT_PREMULTIPLY;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
+                         }
+                         else if (state->blittingflags & (DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA | DSBLIT_SRC_PREMULTCOLOR)) {
+                              if (gdev->prog_index != GLES2_BLIT_COLOR) {
+                                   gdev->prog_index = GLES2_BLIT_COLOR;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
+                         }
+                         else {
+                              if (gdev->prog_index != GLES2_BLIT) {
+                                   gdev->prog_index = GLES2_BLIT;
+                                   glUseProgram(gdev->progs[gdev->prog_index].obj);
+                              }
                          }
                     }
                }
@@ -910,6 +1119,7 @@ gles2SetState(void                *drv,
                // We should have a valid program; check destination and source.
                GLES2_CHECK_VALIDATE(DESTINATION);
                GLES2_CHECK_VALIDATE(SOURCE);
+               GLES2_CHECK_VALIDATE(SRC_CONVOLUTION);
 
                // If normal blitting or color keying is used...
                if (accel == DFXL_BLIT || (state->blittingflags & DSBLIT_SRC_COLORKEY)) {
@@ -925,7 +1135,21 @@ gles2SetState(void                *drv,
                // Check if DSRO_MATRIX needs to be loaded.
                GLES2_CHECK_VALIDATE(MATRIX);
 
-               if (!blend) {
+               // If alpha blending is used...
+               if (blend) {
+                    // ...require valid blend functions.
+                    GLES2_CHECK_VALIDATE(BLENDFUNC);
+                    glEnable(GL_BLEND);
+               }
+               else {
+                    if (state->blittingflags & DSBLIT_SRC_COLORKEY) {
+                         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+                         glEnable(GL_BLEND);
+                    } else {
+                         glBlendFunc(GL_ONE, GL_ZERO);
+                         glDisable(GL_BLEND);
+                    }
+
                     // Check if colorkey needs to be loaded.
                     GLES2_CHECK_VALIDATE(COLORKEY);
                }
@@ -963,6 +1187,19 @@ gles2SetState(void                *drv,
       */
      gdev->prog_last = gdev->prog_index;
 
+
+#ifdef DIRECTFB_GLES2_PVR2D
+     gdrv->bltinfo.BlitFlags = PVR2D_BLIT_DISABLE_ALL;
+
+//     if (state->blittingflags & DSBLIT_BLEND_ALPHACHANNEL)
+//          gdrv->bltinfo.BlitFlags |= PVR2D_BLIT_PERPIXEL_ALPHABLEND_ENABLE;
+
+//     if (state->blittingflags & DSBLIT_BLEND_COLORALPHA) {
+//          gdrv->bltinfo.BlitFlags |= PVR2D_BLIT_GLOBAL_ALPHA_ENABLE;
+//          gdrv->bltinfo.GlobalAlphaValue = state->color.a;
+//     }
+#endif
+
      /*
       * 4) Clear modification flags
       *
@@ -999,8 +1236,14 @@ gles2FillRectangle(void *drv, void *dev, DFBRectangle *rect)
      D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d)\n",
                 __FUNCTION__, DFB_RECTANGLE_VALS(rect));
 
+     enterMode( drv, dev, MODE_GLES2 );
+
      glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
-     glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
+     if (rect->h == 1)
+          glDrawArrays(GL_LINES, 0, 2);
+     else
+          glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
 
      // XXX hood - how are these magic numbers determined?
      gdrv->calls += 1 + rect->w * rect->h / (23 * 42);
@@ -1028,6 +1271,8 @@ gles2DrawRectangle(void *drv, void *dev, DFBRectangle *rect)
      D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d)\n",
                 __FUNCTION__, DFB_RECTANGLE_VALS(rect));
 
+     enterMode( drv, dev, MODE_GLES2 );
+
      glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
      glDrawArrays(GL_LINE_LOOP, 0, 4);
 
@@ -1056,6 +1301,8 @@ gles2DrawLine(void *drv, void *dev, DFBRegion *line)
      D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4d,%4d)\n",
                 __FUNCTION__, DFB_REGION_VALS(line));
 
+     enterMode( drv, dev, MODE_GLES2 );
+
      glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
      glDrawArrays(GL_LINES, 0, 2);
 
@@ -1080,6 +1327,8 @@ gles2FillTriangle(void *drv, void *dev, DFBTriangle *tri)
      D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4d,%4d-%4d,%4d)\n", __FUNCTION__,
                 tri->x1, tri->y1, tri->x2, tri->y2, tri->x3, tri->y3);
 
+     enterMode( drv, dev, MODE_GLES2 );
+
      glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
      glDrawArrays(GL_TRIANGLES, 0, 3);
 
@@ -1096,45 +1345,75 @@ gles2Blit(void *drv, void *dev, DFBRectangle *srect, int dx, int dy)
 {
      GLES2DriverData *gdrv = drv;
 
-     float x1 = dx;
-     float y1 = dy;
-     float x2 = srect->w + x1;
-     float y2 = srect->h + y1;
+#ifdef DIRECTFB_GLES2_PVR2D
+     if (gdrv->pvr2d_dest && gdrv->pvr2d_source) {
+          PVR2DERROR ePVR2DStatus;
 
-     float tx1 = srect->x;
-     float ty1 = srect->y;
-     float tx2 = srect->w + tx1;
-     float ty2 = srect->h + ty1;
+          gdrv->bltinfo.DstX   = dx;
+          gdrv->bltinfo.DstY   = dy;
+          gdrv->bltinfo.DSizeX = srect->w;
+          gdrv->bltinfo.DSizeY = srect->h;
 
-     GLfloat pos[] = {
-          x1, y1,   x2, y1,   x2, y2,   x1, y2
-     };
+          gdrv->bltinfo.SrcX   = srect->x;
+          gdrv->bltinfo.SrcY   = srect->y;
+          gdrv->bltinfo.SizeX  = srect->w;
+          gdrv->bltinfo.SizeY  = srect->h;
 
-     GLfloat tex[8];
+          gdrv->bltinfo.CopyCode = 0xcc;
 
-     D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d)\n",
-                __FUNCTION__, dx, dy, srect->w, srect->h, srect->x, srect->y);
+          enterMode( drv, dev, MODE_PVR2D );
 
-     if (gdrv->blittingflags & DSBLIT_ROTATE180) {
-          tex[0] = tx2; tex[1] = ty2;
-          tex[2] = tx1; tex[3] = ty2;
-          tex[4] = tx1; tex[5] = ty1;
-          tex[6] = tx2; tex[7] = ty1;
-     }
-     else {
-          tex[0] = tx1; tex[1] = ty1;
-          tex[2] = tx2; tex[3] = ty1;
-          tex[4] = tx2; tex[5] = ty2;
-          tex[6] = tx1; tex[7] = ty2;
+          ePVR2DStatus = PVR2DBlt( gdrv->hPVR2DContext, &gdrv->bltinfo );
+          if (ePVR2DStatus) {
+               D_ERROR( "DirectFB/PVR2D: PVR2DBlt() failed! (status %d)\n", ePVR2DStatus );
+     //          return false;
+          }
      }
+     else
+#endif
+     {
+          float x1 = dx;
+          float y1 = dy;
+          float x2 = srect->w + x1;
+          float y2 = srect->h + y1;
 
-     glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
-     glVertexAttribPointer(GLES2VA_TEXCOORDS, 2, GL_FLOAT, GL_FALSE, 0, tex);
+          float tx1 = srect->x;
+          float ty1 = srect->y;
+          float tx2 = srect->w + tx1;
+          float ty2 = srect->h + ty1;
 
-     glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+          GLfloat pos[] = {
+               x1, y1,   x2, y1,   x2, y2,   x1, y2
+          };
 
-     // XXX hood - how are these magic numbers determined?
-     gdrv->calls += 1 + srect->w * srect->h / (23 * 42);
+          GLfloat tex[8];
+
+          D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d)\n",
+                     __FUNCTION__, dx, dy, srect->w, srect->h, srect->x, srect->y);
+
+          if (gdrv->blittingflags & DSBLIT_ROTATE180) {
+               tex[0] = tx2; tex[1] = ty2;
+               tex[2] = tx1; tex[3] = ty2;
+               tex[4] = tx1; tex[5] = ty1;
+               tex[6] = tx2; tex[7] = ty1;
+          }
+          else {
+               tex[0] = tx1; tex[1] = ty1;
+               tex[2] = tx2; tex[3] = ty1;
+               tex[4] = tx2; tex[5] = ty2;
+               tex[6] = tx1; tex[7] = ty2;
+          }
+
+          enterMode( drv, dev, MODE_GLES2 );
+
+          glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
+          glVertexAttribPointer(GLES2VA_TEXCOORDS, 2, GL_FLOAT, GL_FALSE, 0, tex);
+
+          glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
+          // XXX hood - how are these magic numbers determined?
+          gdrv->calls += 1 + srect->w * srect->h / (23 * 42);
+     }
 
      return true;
 }
@@ -1147,72 +1426,104 @@ gles2BatchBlit(void *drv, void *dev,
                const DFBRectangle *rects, const DFBPoint *points,
                unsigned int num, unsigned int *ret_num)
 {
-     GLES2DriverData *gdrv = drv;
      int              i;
+     GLES2DriverData *gdrv = drv;
 
-     GLfloat pos[num*12];
-     GLfloat tex[num*12];
+#ifdef DIRECTFB_GLES2_PVR2D
+     if (gdrv->pvr2d_dest && gdrv->pvr2d_source) {
+          PVR2DERROR ePVR2DStatus;
 
-     //     D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d)\n",
-     //                __FUNCTION__, dx, dy, srect->w, srect->h, srect->x, srect->y);
+          gdrv->bltinfo.CopyCode = 0xcc;
 
-     for (i=0; i<num; i++) {
-          float x1 = points[i].x;
-          float y1 = points[i].y;
-          float x2 = rects[i].w + x1;
-          float y2 = rects[i].h + y1;
+          enterMode( drv, dev, MODE_PVR2D );
 
-          float tx1 = rects[i].x;
-          float ty1 = rects[i].y;
-          float tx2 = rects[i].w + tx1;
-          float ty2 = rects[i].h + ty1;
+          for (i=0; i<num; i++) {
+               gdrv->bltinfo.DstX   = points[i].x;
+               gdrv->bltinfo.DstY   = points[i].y;
+               gdrv->bltinfo.DSizeX = rects[i].w;
+               gdrv->bltinfo.DSizeY = rects[i].h;
 
-          pos[i*12+0] = x1;
-          pos[i*12+1] = y1;
+               gdrv->bltinfo.SrcX   = rects[i].x;
+               gdrv->bltinfo.SrcY   = rects[i].y;
+               gdrv->bltinfo.SizeX  = rects[i].w;
+               gdrv->bltinfo.SizeY  = rects[i].h;
 
-          pos[i*12+2] = x2;
-          pos[i*12+3] = y1;
+               ePVR2DStatus = PVR2DBlt( gdrv->hPVR2DContext, &gdrv->bltinfo );
+               if (ePVR2DStatus) {
+                    D_ERROR( "DirectFB/PVR2D: PVR2DBlt() failed! (status %d)\n", ePVR2DStatus );
+          //          return false;
+               }
+          }
+     }
+     else
+#endif
+     {
 
-          pos[i*12+4] = x2;
-          pos[i*12+5] = y2;
+          GLfloat pos[num*12];
+          GLfloat tex[num*12];
 
-          pos[i*12+6] = x2;
-          pos[i*12+7] = y2;
+          //     D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d)\n",
+          //                __FUNCTION__, dx, dy, srect->w, srect->h, srect->x, srect->y);
 
-          pos[i*12+8] = x1;
-          pos[i*12+9] = y1;
+          for (i=0; i<num; i++) {
+               float x1 = points[i].x;
+               float y1 = points[i].y;
+               float x2 = rects[i].w + x1;
+               float y2 = rects[i].h + y1;
 
-          pos[i*12+10] = x1;
-          pos[i*12+11] = y2;
+               float tx1 = rects[i].x;
+               float ty1 = rects[i].y;
+               float tx2 = rects[i].w + tx1;
+               float ty2 = rects[i].h + ty1;
 
-          if (gdrv->blittingflags & DSBLIT_ROTATE180) {
-               tex[i*12+0] = tx2; tex[i*12+1] = ty2;
-               tex[i*12+2] = tx1; tex[i*12+3] = ty2;
-               tex[i*12+4] = tx1; tex[i*12+5] = ty1;
+               pos[i*12+0] = x1;
+               pos[i*12+1] = y1;
 
-               tex[i*12+6] = tx1; tex[i*12+7] = ty1;
-               tex[i*12+8] = tx2; tex[i*12+9] = ty2;
-               tex[i*12+10] = tx2; tex[i*12+11] = ty1;
-          }
-          else {
-               tex[i*12+0] = tx1; tex[i*12+1] = ty1;
-               tex[i*12+2] = tx2; tex[i*12+3] = ty1;
-               tex[i*12+4] = tx2; tex[i*12+5] = ty2;
+               pos[i*12+2] = x2;
+               pos[i*12+3] = y1;
 
-               tex[i*12+6] = tx2; tex[i*12+7] = ty2;
-               tex[i*12+8] = tx1; tex[i*12+9] = ty1;
-               tex[i*12+10] = tx1; tex[i*12+11] = ty2;
-          }
+               pos[i*12+4] = x2;
+               pos[i*12+5] = y2;
 
-          // XXX hood - how are these magic numbers determined?
-          gdrv->calls += 1 + rects[i].w * rects[i].h / (23 * 42);
-     }
+               pos[i*12+6] = x2;
+               pos[i*12+7] = y2;
 
-     glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
-     glVertexAttribPointer(GLES2VA_TEXCOORDS, 2, GL_FLOAT, GL_FALSE, 0, tex);
+               pos[i*12+8] = x1;
+               pos[i*12+9] = y1;
 
-     glDrawArrays(GL_TRIANGLES, 0, num*6);
+               pos[i*12+10] = x1;
+               pos[i*12+11] = y2;
 
+               if (gdrv->blittingflags & DSBLIT_ROTATE180) {
+                    tex[i*12+0] = tx2; tex[i*12+1] = ty2;
+                    tex[i*12+2] = tx1; tex[i*12+3] = ty2;
+                    tex[i*12+4] = tx1; tex[i*12+5] = ty1;
+
+                    tex[i*12+6] = tx1; tex[i*12+7] = ty1;
+                    tex[i*12+8] = tx2; tex[i*12+9] = ty2;
+                    tex[i*12+10] = tx2; tex[i*12+11] = ty1;
+               }
+               else {
+                    tex[i*12+0] = tx1; tex[i*12+1] = ty1;
+                    tex[i*12+2] = tx2; tex[i*12+3] = ty1;
+                    tex[i*12+4] = tx2; tex[i*12+5] = ty2;
+
+                    tex[i*12+6] = tx2; tex[i*12+7] = ty2;
+                    tex[i*12+8] = tx1; tex[i*12+9] = ty1;
+                    tex[i*12+10] = tx1; tex[i*12+11] = ty2;
+               }
+
+               // XXX hood - how are these magic numbers determined?
+               gdrv->calls += 1 + rects[i].w * rects[i].h / (23 * 42);
+          }
+
+          enterMode( drv, dev, MODE_GLES2 );
+
+          glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
+          glVertexAttribPointer(GLES2VA_TEXCOORDS, 2, GL_FLOAT, GL_FALSE, 0, tex);
+
+          glDrawArrays(GL_TRIANGLES, 0, num*6);
+     }
 
      return true;
 }
@@ -1226,46 +1537,136 @@ gles2StretchBlit(void *drv, void *dev,
 {
      GLES2DriverData *gdrv = drv;
 
-     float x1 = drect->x;
-     float y1 = drect->y;
-     float x2 = drect->w + x1;
-     float y2 = drect->h + y1;
+#ifdef DIRECTFB_GLES2_PVR2D
+     if (gdrv->pvr2d_dest && gdrv->pvr2d_source) {
+          PVR2DERROR ePVR2DStatus;
 
-     float tx1 = srect->x;
-     float ty1 = srect->y;
-     float tx2 = srect->w + tx1;
-     float ty2 = srect->h + ty1;
+          gdrv->bltinfo.DstX   = drect->x;
+          gdrv->bltinfo.DstY   = drect->y;
+          gdrv->bltinfo.DSizeX = drect->w;
+          gdrv->bltinfo.DSizeY = drect->h;
 
-     GLfloat pos[] = {
-          x1, y1,   x2, y1,   x2, y2,   x1, y2
-     };
+          gdrv->bltinfo.SrcX   = srect->x;
+          gdrv->bltinfo.SrcY   = srect->y;
+          gdrv->bltinfo.SizeX  = srect->w;
+          gdrv->bltinfo.SizeY  = srect->h;
 
-     GLfloat tex[8];
+          gdrv->bltinfo.CopyCode = 0xcc;
 
-     D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d-%4dx%4d)\n",
-                __FUNCTION__, DFB_RECTANGLE_VALS(drect),
-                DFB_RECTANGLE_VALS(srect));
+          enterMode( drv, dev, MODE_PVR2D );
 
-     if (gdrv->blittingflags & DSBLIT_ROTATE180) {
-          tex[0] = tx2; tex[1] = ty2;
-          tex[2] = tx1; tex[3] = ty2;
-          tex[4] = tx1; tex[5] = ty1;
-          tex[6] = tx2; tex[7] = ty1;
+          ePVR2DStatus = PVR2DBlt( gdrv->hPVR2DContext, &gdrv->bltinfo );
+          if (ePVR2DStatus) {
+     //          D_ERROR( "DirectFB/PVR2D: PVR2DBlt() failed! (status %d)\n", ePVR2DStatus );
+     //          return false;
+          }
      }
-     else {
-          tex[0] = tx1; tex[1] = ty1;
-          tex[2] = tx2; tex[3] = ty1;
-          tex[4] = tx2; tex[5] = ty2;
-          tex[6] = tx1; tex[7] = ty2;
+     else
+#endif
+     {
+          float x1 = drect->x;
+          float y1 = drect->y;
+          float x2 = drect->w + x1;
+          float y2 = drect->h + y1;
+
+          float tx1 = srect->x;
+          float ty1 = srect->y;
+          float tx2 = srect->w + tx1;
+          float ty2 = srect->h + ty1;
+
+          GLfloat pos[] = {
+               x1, y1,   x2, y1,   x2, y2,   x1, y2
+          };
+
+          GLfloat tex[8];
+
+          D_DEBUG_AT(GLES2__2D, "%s(%4d,%4d-%4dx%4d <- %4d,%4d-%4dx%4d)\n",
+                     __FUNCTION__, DFB_RECTANGLE_VALS(drect),
+                     DFB_RECTANGLE_VALS(srect));
+
+          if (gdrv->blittingflags & DSBLIT_ROTATE180) {
+               tex[0] = tx2; tex[1] = ty2;
+               tex[2] = tx1; tex[3] = ty2;
+               tex[4] = tx1; tex[5] = ty1;
+               tex[6] = tx2; tex[7] = ty1;
+          }
+          else {
+               tex[0] = tx1; tex[1] = ty1;
+               tex[2] = tx2; tex[3] = ty1;
+               tex[4] = tx2; tex[5] = ty2;
+               tex[6] = tx1; tex[7] = ty2;
+          }
+
+          enterMode( drv, dev, MODE_GLES2 );
+
+          glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
+          glVertexAttribPointer(GLES2VA_TEXCOORDS, 2, GL_FLOAT, GL_FALSE, 0, tex);
+
+          glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
+          // XXX hood - how are these magic numbers determined?
+          gdrv->calls += 1 + drect->w * drect->h / (23 * 42);
      }
 
-     glVertexAttribPointer(GLES2VA_POSITIONS, 2, GL_FLOAT, GL_FALSE, 0, pos);
+     return true;
+}
+
+/*
+ * Textureize triangles using the current hardware state.
+ */
+bool
+gles2TextureTriangles( void                 *drv,
+                       void                 *dev,
+                       DFBVertex            *vertices,
+                       int                   num,
+                       DFBTriangleFormation  formation )
+{
+     int              i;
+     int              type = 0;
+     GLES2DriverData *gdrv = drv;
+     float            pos[num*4];
+     float            tex[num*2];
+
+     D_DEBUG_AT( GLES2__2D, "%s( %p, %d, %d )\n", __FUNCTION__, vertices, num, formation );
+
+     switch (formation) {
+          case DTTF_LIST:
+               type = GL_TRIANGLES;
+               break;
+
+          case DTTF_STRIP:
+               type = GL_TRIANGLE_STRIP;
+               break;
+
+          case DTTF_FAN:
+               type = GL_TRIANGLE_FAN;
+               break;
+
+          default:
+               return false;
+     }
+
+     for (i=0; i<num; i++) {
+          D_DEBUG_AT( GLES2__2D, "  -> [%2d] %5.1f,%5.1f,%5.1f,%5.1f (%5.3f,%5.3f)\n", i,
+                      vertices[i].x, vertices[i].y, vertices[i].z, vertices[i].w, vertices[i].s, vertices[i].t );
+
+          pos[i*4+0] = vertices[i].x;
+          pos[i*4+1] = vertices[i].y;
+          pos[i*4+2] = vertices[i].z;
+          pos[i*4+3] = vertices[i].w;
+
+          tex[i*2+0] = vertices[i].s;
+          tex[i*2+1] = vertices[i].t;
+     }
+
+     enterMode( drv, dev, MODE_GLES2 );
+
+     glVertexAttribPointer(GLES2VA_POSITIONS, 4, GL_FLOAT, GL_FALSE, 0, pos);
      glVertexAttribPointer(GLES2VA_TEXCOORDS, 2, GL_FLOAT, GL_FALSE, 0, tex);
 
-     glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+     glDrawArrays(type, 0, num);
 
-     // XXX hood - how are these magic numbers determined?
-     gdrv->calls += 1 + drect->w * drect->h / (23 * 42);
+     gdrv->calls += num;
 
      return true;
 }
diff --git a/gfxdrivers/gles2/gles2_2d.h b/gfxdrivers/gles2/gles2_2d.h
index 6629811..5603a09 100644
--- a/gfxdrivers/gles2/gles2_2d.h
+++ b/gfxdrivers/gles2/gles2_2d.h
@@ -42,10 +42,12 @@
                                            DSBLIT_ROTATE180          | \
                                            DSBLIT_SRC_PREMULTIPLY    | \
                                            DSBLIT_SRC_PREMULTCOLOR   | \
+                                           DSBLIT_SRC_CONVOLUTION    | \
                                            DSBLIT_SRC_COLORKEY)
 
 #define GLES2_SUPPORTED_BLITTINGFUNCTIONS (DFXL_BLIT | \
-                                           DFXL_STRETCHBLIT)
+                                           DFXL_STRETCHBLIT | \
+                                           DFXL_TEXTRIANGLES)
 
 
 DFBResult gles2EngineSync   (void                *drv,
@@ -99,5 +101,11 @@ bool      gles2StretchBlit  (void                *drv,
 			     DFBRectangle        *srect,
 			     DFBRectangle        *drect);
 
+bool
+gles2TextureTriangles( void                 *drv,
+                       void                 *dev,
+                       DFBVertex            *vertices,
+                       int                   num,
+                       DFBTriangleFormation  formation );
 #endif
 
diff --git a/gfxdrivers/gles2/gles2_gfxdriver.c b/gfxdrivers/gles2/gles2_gfxdriver.c
index b88e2eb..953f33c 100644
--- a/gfxdrivers/gles2/gles2_gfxdriver.c
+++ b/gfxdrivers/gles2/gles2_gfxdriver.c
@@ -97,23 +97,27 @@ driver_init_driver(CoreGraphicsDevice  *device,
                    void                *device_data,
                    CoreDFB             *core)
 {
+#ifdef DIRECTFB_GLES2_PVR2D
+     PVR2DERROR       ePVR2DStatus;
+#endif
      GLES2DriverData *drv = driver_data;
 
      D_DEBUG_AT(GLES2__2D, "%s()\n", __FUNCTION__);
 
      // initialize function pointers
-     funcs->EngineSync    = gles2EngineSync;
-     funcs->EngineReset   = gles2EngineReset;
-     funcs->EmitCommands  = gles2EmitCommands;
-     funcs->CheckState    = gles2CheckState;
-     funcs->SetState      = gles2SetState;
-     funcs->FillRectangle = gles2FillRectangle;
-     funcs->DrawRectangle = gles2DrawRectangle;
-     funcs->DrawLine      = gles2DrawLine;
-     funcs->FillTriangle  = gles2FillTriangle;
-     funcs->Blit          = gles2Blit;
-     funcs->BatchBlit     = gles2BatchBlit;
-     funcs->StretchBlit   = gles2StretchBlit;
+     funcs->EngineSync       = gles2EngineSync;
+     funcs->EngineReset      = gles2EngineReset;
+     funcs->EmitCommands     = gles2EmitCommands;
+     funcs->CheckState       = gles2CheckState;
+     funcs->SetState         = gles2SetState;
+     funcs->FillRectangle    = gles2FillRectangle;
+     funcs->DrawRectangle    = gles2DrawRectangle;
+     funcs->DrawLine         = gles2DrawLine;
+     funcs->FillTriangle     = gles2FillTriangle;
+     funcs->Blit             = gles2Blit;
+     funcs->BatchBlit        = gles2BatchBlit;
+     funcs->StretchBlit      = gles2StretchBlit;
+     funcs->TextureTriangles = gles2TextureTriangles;
 
      // Choose accelerated font format
      if (!dfb_config->software_only) {
@@ -135,6 +139,28 @@ driver_init_driver(CoreGraphicsDevice  *device,
      glDepthMask( GL_FALSE );
      glDisable( GL_DEPTH_TEST );
 
+
+
+#ifdef DIRECTFB_GLES2_PVR2D
+     drv->nDevices = PVR2DEnumerateDevices(0);
+     if (drv->nDevices < 1) {
+          D_ERROR( "DirectFB/CarE1: PVR2DEnumerateDevices(0) returned %d!\n", drv->nDevices );
+          return DFB_INIT;
+     }
+
+     drv->pDevInfo = (PVR2DDEVICEINFO *) malloc(drv->nDevices * sizeof(PVR2DDEVICEINFO));
+
+     PVR2DEnumerateDevices(drv->pDevInfo);
+
+     drv->nDeviceNum = drv->pDevInfo[0].ulDevID;
+
+     ePVR2DStatus = PVR2DCreateDeviceContext (drv->nDeviceNum, &drv->hPVR2DContext, 0);
+     if (ePVR2DStatus) {
+          D_ERROR( "DirectFB/CarE1: PVR2DCreateDeviceContext() failed! (status %d)\n", ePVR2DStatus );
+          return DFB_INIT;
+     }
+#endif
+
      return DFB_OK;
 }
 
@@ -144,13 +170,16 @@ driver_init_device(CoreGraphicsDevice *device,
                    void               *driver_data,
                    void               *device_data)
 {
+     int           err;
      const char   *renderer;
+     const char   *extensions;
      DFBResult     status;
 
      D_DEBUG_AT(GLES2__2D, "%s()\n", __FUNCTION__);
 
      // Now that we have a connection and can query GLES.
      renderer = (const char*)glGetString(GL_RENDERER);
+     extensions = (const char*)glGetString(GL_EXTENSIONS);
 
      // Fill device info.
      snprintf(device_info->vendor,
@@ -158,6 +187,13 @@ driver_init_device(CoreGraphicsDevice *device,
      snprintf(device_info->name,
               DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH, "%s", renderer ?: "Unknown");
 
+     D_INFO("GL Extensions: %s\n", extensions);
+
+     if ((err = glGetError()) != 0) {
+          D_ERROR( "DirectFB/GLES2: Error before gles2_init_shader_programs! (error = %x)\n", err );
+          //return DFB_FAILURE;
+     }
+
      // Initialize shader program objects, shared across all EGL contexts.
      status = gles2_init_shader_programs((GLES2DeviceData *)device_data);
 
@@ -176,6 +212,12 @@ driver_init_device(CoreGraphicsDevice *device,
      device_info->caps.drawing  = GLES2_SUPPORTED_DRAWINGFLAGS;
      device_info->caps.blitting = GLES2_SUPPORTED_BLITTINGFLAGS;
 
+
+     if ((err = glGetError()) != 0) {
+          D_ERROR( "DirectFB/GLES2: Error at end of driver_init_device! (error = %x)\n", err );
+          //return DFB_FAILURE;
+     }
+
      return DFB_OK;
 }
 
diff --git a/gfxdrivers/gles2/gles2_gfxdriver.h b/gfxdrivers/gles2/gles2_gfxdriver.h
index 4bf90a4..6e83c69 100644
--- a/gfxdrivers/gles2/gles2_gfxdriver.h
+++ b/gfxdrivers/gles2/gles2_gfxdriver.h
@@ -38,6 +38,11 @@
 #include <GLES2/gl2.h>
 #endif
 
+#ifdef DIRECTFB_GLES2_PVR2D
+#include <pvr2d.h>
+#endif
+
+
 typedef enum {
      GLES2BF_UPDATE_TARGET  = 0x00000001,
      GLES2BF_UPDATE_TEXTURE = 0x00000002,
@@ -70,6 +75,7 @@ typedef struct {
      GLint  dfbColorkey;  // location of colorkey RGB color
      GLint  dfbTexScale;  // location of scale factors to normalized tex coords
      GLint  dfbSampler;   // location of 2D texture sampler
+     GLint  dfbConvFilter;// location of convolution filter
      char  *name;         // program object name for debugging
      int    v_flags;      // validation flags
 } GLES2ProgramInfo;
@@ -91,10 +97,20 @@ typedef enum {
      GLES2_BLIT_COLORKEY_MAT    =  7,
      GLES2_BLIT_PREMULTIPLY     =  8,
      GLES2_BLIT_PREMULTIPLY_MAT =  9,
-     GLES2_NUM_PROGRAMS         = 10,
-     GLES2_INVALID_PROGRAM      = 11
+     GLES2_TEXTRI               = 10,
+     GLES2_TEXTRI_COLOR         = 11,
+     GLES2_TEXTRI_COLORKEY      = 12,
+     GLES2_TEXTRI_PREMULTIPLY   = 13,
+     GLES2_NUM_PROGRAMS         = 14,
+     GLES2_INVALID_PROGRAM      = 15
 } GLES2ProgramIndex;
 
+typedef enum {
+     MODE_IDLE,
+     MODE_GLES2,
+     MODE_PVR2D
+} EngineMode;
+
 typedef struct {
      /*
       * Program objects and uniform variable locations.  These are shared
@@ -114,11 +130,24 @@ typedef struct {
      GLuint                   fbo;
 #endif
 
-
      DFBSurfaceBlittingFlags  blittingflags;
 
      // Flush every bunch of commands
      unsigned int             calls;
+
+#ifdef DIRECTFB_GLES2_PVR2D
+     int                 nDevices;
+     PVR2DDEVICEINFO    *pDevInfo;
+     PVR2DCONTEXTHANDLE  hPVR2DContext;
+     int                 nDeviceNum;
+
+     PVR2DBLTINFO        bltinfo;
+
+     PVR2DMEMINFO	*pvr2d_dest;		/* destination memory */
+     PVR2DMEMINFO	*pvr2d_source;		/* source memory */
+#endif
+
+     EngineMode          engine_mode;
 } GLES2DriverData;
 
 DFBResult
diff --git a/gfxdrivers/gles2/gles2_shaders.c b/gfxdrivers/gles2/gles2_shaders.c
index 0d58ddc..6eeefaa 100644
--- a/gfxdrivers/gles2/gles2_shaders.c
+++ b/gfxdrivers/gles2/gles2_shaders.c
@@ -140,7 +140,7 @@ init_program(GLuint prog_obj,
 DFBResult
 gles2_init_shader_programs(GLES2DeviceData *dev)
 {
-     int i;
+     int i, err;
      GLuint prog;
      DFBBoolean status;
 
@@ -183,6 +183,11 @@ gles2_init_shader_programs(GLES2DeviceData *dev)
           goto fail;
      }
 
+     if ((err = glGetError()) != 0) {
+          D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+          //return DFB_FAILURE;
+     }
+
      prog = glCreateProgram();
      status = init_program(prog, "draw_vert_mat", draw_vert_mat_src,
                            "draw_frag", draw_frag_src, DFB_FALSE);
@@ -201,6 +206,11 @@ gles2_init_shader_programs(GLES2DeviceData *dev)
           goto fail;
      }
 
+     if ((err = glGetError()) != 0) {
+          D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+          //return DFB_FAILURE;
+     }
+
      /*
       * blit_program transforms a vertex by the current model-view-projection
       * matrix, applies texture sample colors to fragments.
@@ -215,6 +225,7 @@ gles2_init_shader_programs(GLES2DeviceData *dev)
           GET_UNIFORM_LOCATION(dev, GLES2_BLIT, dfbScale);
           GET_UNIFORM_LOCATION(dev, GLES2_BLIT, dfbTexScale);
           GET_UNIFORM_LOCATION(dev, GLES2_BLIT, dfbSampler);
+//          GET_UNIFORM_LOCATION(dev, GLES2_BLIT, dfbConvFilter);
 
           // For now we always use texture unit 0 (GL_TEXTURE0).
           glUniform1i(dev->progs[GLES2_BLIT].dfbSampler, 0);
@@ -382,6 +393,11 @@ gles2_init_shader_programs(GLES2DeviceData *dev)
           goto fail;
      }
 
+     if ((err = glGetError()) != 0) {
+          D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+          //return DFB_FAILURE;
+     }
+
      prog = glCreateProgram();
      status = init_program(prog, "blit_vert_mat", blit_vert_mat_src,
                            "blit_premultiply_frag", blit_premultiply_frag_src,
@@ -391,11 +407,36 @@ gles2_init_shader_programs(GLES2DeviceData *dev)
           dev->progs[GLES2_BLIT_PREMULTIPLY_MAT].name = "blit_premultiply_mat";
 
           GET_UNIFORM_LOCATION(dev, GLES2_BLIT_PREMULTIPLY_MAT, dfbColor);
+
+          if ((err = glGetError()) != 0) {
+               D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+               //return DFB_FAILURE;
+          }
           GET_UNIFORM_LOCATION(dev, GLES2_BLIT_PREMULTIPLY_MAT, dfbROMatrix);
+
+          if ((err = glGetError()) != 0) {
+               D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+               //return DFB_FAILURE;
+          }
           GET_UNIFORM_LOCATION(dev, GLES2_BLIT_PREMULTIPLY_MAT, dfbMVPMatrix);
+
+          if ((err = glGetError()) != 0) {
+               D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+               //return DFB_FAILURE;
+          }
           GET_UNIFORM_LOCATION(dev, GLES2_BLIT_PREMULTIPLY_MAT, dfbTexScale);
+
+          if ((err = glGetError()) != 0) {
+               D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+               //return DFB_FAILURE;
+          }
           GET_UNIFORM_LOCATION(dev, GLES2_BLIT_PREMULTIPLY_MAT, dfbSampler);
 
+          if ((err = glGetError()) != 0) {
+               D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+               //return DFB_FAILURE;
+          }
+
           // For now we always use texture unit 0 (GL_TEXTURE0).
           glUniform1i(dev->progs[GLES2_BLIT_PREMULTIPLY_MAT].dfbSampler, 0);
 
@@ -406,6 +447,118 @@ gles2_init_shader_programs(GLES2DeviceData *dev)
           goto fail;
      }
 
+     if ((err = glGetError()) != 0) {
+          D_ERROR( "DirectFB/GLES2: Error at line %d of gles2_init_shader_programs! (error = %x)\n", __LINE__, err );
+          //return DFB_FAILURE;
+     }
+
+     /*
+      * blit_program transforms a vertex by the current model-view-projection
+      * matrix, applies texture sample colors to fragments.
+      */
+     prog = glCreateProgram();
+     status = init_program(prog, "blit_vert_textri", blit_vert_textri_src,
+                           "blit_frag", blit_frag_src, DFB_TRUE);
+     if (status) {
+          dev->progs[GLES2_TEXTRI].obj = prog;
+          dev->progs[GLES2_TEXTRI].name = "textri";
+
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI, dfbScale);
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI, dfbSampler);
+
+          // For now we always use texture unit 0 (GL_TEXTURE0).
+          glUniform1i(dev->progs[GLES2_TEXTRI].dfbSampler, 0);
+
+          D_DEBUG_AT(GLES2__2D, "-> created textri_program\n");
+     }
+     else {
+          D_ERROR("GLES2/Driver: textri_program init failed!\n");
+          goto fail;
+     }
+
+     /*
+      * blit_color_program transforms a vertex by the current model-view-projection
+      * matrix, applies texture sample colors to fragments, and modulates the
+      * colors with a static RGBA color.  Modulation is effectively disabled
+      * by setting static color components to 1.0.
+      */
+     prog = glCreateProgram();
+     status = init_program(prog, "blit_color_vert_textri", blit_vert_textri_src,
+                           "blit_color_frag", blit_color_frag_src, DFB_TRUE);
+     if (status) {
+          dev->progs[GLES2_TEXTRI_COLOR].obj = prog;
+          dev->progs[GLES2_TEXTRI_COLOR].name = "textri_color";
+
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_COLOR, dfbColor);
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_COLOR, dfbScale);
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_COLOR, dfbSampler);
+
+          // For now we always use texture unit 0 (GL_TEXTURE0).
+          glUniform1i(dev->progs[GLES2_TEXTRI_COLOR].dfbSampler, 0);
+
+          D_DEBUG_AT(GLES2__2D, "-> created textri_color_program\n");
+     }
+     else {
+          D_ERROR("GLES2/Driver: textri_color_program init failed!\n");
+          goto fail;
+     }
+
+     /*
+      * blit_colorkey_program does the same as blit_program with the addition
+      * of source color keying.  Shaders don't have access to destination
+      * pixels so color keying can be on the source only.
+      */
+     prog = glCreateProgram();
+     status = init_program(prog, "blit_vert_textri", blit_vert_textri_src,
+                           "blit_colorkey_frag", blit_colorkey_frag_src,
+                           DFB_TRUE);
+     if (status) {
+          dev->progs[GLES2_TEXTRI_COLORKEY].obj = prog;
+          dev->progs[GLES2_TEXTRI_COLORKEY].name = "textri_colorkey";
+
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_COLORKEY, dfbColor);
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_COLORKEY, dfbScale);
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_COLORKEY, dfbSampler);
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_COLORKEY, dfbColorkey);
+
+          // For now we always use texture unit 0 (GL_TEXTURE0).
+          glUniform1i(dev->progs[GLES2_TEXTRI_COLORKEY].dfbSampler, 0);
+
+          D_DEBUG_AT(GLES2__2D, "-> created textri_colorkey_program\n");
+     }
+     else {
+          D_ERROR("GLES2/Driver: textri_colorkey_program init failed!\n");
+          goto fail;
+     }
+
+     /*
+      * blit_premultiply_program does the same as blit_program with the
+      * addition of pre-multiplication of the source frag color by the source
+      * frag alpha.  Shaders don't have access to destination pixels so
+      * pre-multiplication can be on the source only.
+      */
+     prog = glCreateProgram();
+     status = init_program(prog, "blit_vert_textri", blit_vert_textri_src,
+                           "blit_premultiply_frag", blit_premultiply_frag_src,
+                           DFB_TRUE);
+     if (status) {
+          dev->progs[GLES2_TEXTRI_PREMULTIPLY].obj = prog;
+          dev->progs[GLES2_TEXTRI_PREMULTIPLY].name = "textri_premultiply";
+
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_PREMULTIPLY, dfbColor);
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_PREMULTIPLY, dfbScale);
+          GET_UNIFORM_LOCATION(dev, GLES2_TEXTRI_PREMULTIPLY, dfbSampler);
+
+          // For now we always use texture unit 0 (GL_TEXTURE0).
+          glUniform1i(dev->progs[GLES2_TEXTRI_PREMULTIPLY].dfbSampler, 0);
+
+          D_DEBUG_AT(GLES2__2D, "-> created textri_premultiply_program\n");
+     }
+     else {
+          D_ERROR("GLES2/Driver: textri_premultiply_program init failed!\n");
+          goto fail;
+     }
+
      // No program is yet in use.
      dev->prog_index = GLES2_INVALID_PROGRAM;
      dev->prog_last  = GLES2_INVALID_PROGRAM;
diff --git a/gfxdrivers/gles2/gles2_shaders.h b/gfxdrivers/gles2/gles2_shaders.h
index 0ece181..66c5ae9 100644
--- a/gfxdrivers/gles2/gles2_shaders.h
+++ b/gfxdrivers/gles2/gles2_shaders.h
@@ -77,7 +77,7 @@ void main (void) \
  * Draw fragment in a constant color.
  */
 static const char *draw_frag_src = " \
-uniform "LOWP" vec4 dfbColor; \
+uniform "MEDIUMP" vec4 dfbColor; \
 void main (void) \
 { \
      gl_FragColor = dfbColor; \
@@ -95,8 +95,8 @@ static const char *blit_vert_src = " \
 attribute "HIGHP" vec2   dfbPos; \
 attribute "MEDIUMP" vec2 dfbUV; \
 uniform "HIGHP"   vec3   dfbScale; \
-uniform "MEDIUMP" vec2   dfbTexScale; \
-varying "LOWP"    vec2   varTexCoord; \
+uniform "HIGHP" vec2   dfbTexScale; \
+varying "MEDIUMP"    vec2   varTexCoord; \
 void main (void) \
 { \
      gl_Position.x = dfbScale.x * dfbPos.x - 1.0; \
@@ -116,8 +116,8 @@ attribute "HIGHP" vec2   dfbPos; \
 attribute "MEDIUMP" vec2 dfbUV; \
 uniform "HIGHP"   mat3   dfbMVPMatrix; \
 uniform "HIGHP"   mat3   dfbROMatrix; \
-uniform "MEDIUMP" vec2   dfbTexScale; \
-varying "LOWP"    vec2   varTexCoord; \
+uniform "HIGHP" vec2   dfbTexScale; \
+varying "MEDIUMP"    vec2   varTexCoord; \
 void main (void) \
 { \
      "HIGHP" vec3 pos = dfbMVPMatrix * dfbROMatrix * vec3(dfbPos, 1.0); \
@@ -128,11 +128,64 @@ void main (void) \
 
 
 /*
- * Sample texture and modulate by static color.
+ * This is for TextureTriangles
+ */
+static const char *blit_vert_textri_src = " \
+attribute "HIGHP" vec4   dfbPos; \
+attribute "MEDIUMP" vec2 dfbUV; \
+uniform "HIGHP"   vec3   dfbScale; \
+varying "MEDIUMP"    vec2   varTexCoord; \
+void main (void) \
+{ \
+     float onebyw = 1.0 / dfbPos.w; \
+     gl_Position.x = (dfbScale.x * dfbPos.x - 1.0) * onebyw; \
+     gl_Position.y = (dfbScale.y * dfbPos.y + dfbScale.z) * onebyw; \
+     gl_Position.z = dfbPos.z * onebyw; \
+     gl_Position.w = onebyw; \
+     varTexCoord.s = dfbUV.s; \
+     varTexCoord.t = dfbUV.t; \
+}";
+
+
+/*
+ * Sample texture with convolution filter.
+ */
+static const char *blitconv_frag_src = " \
+uniform sampler2D    dfbSampler; \
+uniform "HIGHP" vec2   dfbTexScale; \
+uniform "MEDIUMP" float  dfbConvFilter[11]; \
+varying "MEDIUMP" vec2  varTexCoord; \
+void main (void) \
+{ \
+     "MEDIUMP" vec4 sample;\
+\
+     if (dfbConvFilter[9] != 0.0) {\
+          sample = (texture2D(dfbSampler, varTexCoord) * dfbConvFilter[4]\
+                    + texture2D(dfbSampler, vec2( varTexCoord.x - dfbTexScale.x, varTexCoord.y - dfbTexScale.y ) ) * dfbConvFilter[0]\
+                    + texture2D(dfbSampler, vec2( varTexCoord.x,                 varTexCoord.y - dfbTexScale.y ) ) * dfbConvFilter[1]\
+                    + texture2D(dfbSampler, vec2( varTexCoord.x + dfbTexScale.x, varTexCoord.y - dfbTexScale.y ) ) * dfbConvFilter[2]\
+                    + texture2D(dfbSampler, vec2( varTexCoord.x - dfbTexScale.x, varTexCoord.y ) ) * dfbConvFilter[3]\
+                    + texture2D(dfbSampler, vec2( varTexCoord.x + dfbTexScale.x, varTexCoord.y ) ) * dfbConvFilter[5]\
+                    + texture2D(dfbSampler, vec2( varTexCoord.x - dfbTexScale.x, varTexCoord.y + dfbTexScale.y ) ) * dfbConvFilter[6]\
+                    + texture2D(dfbSampler, vec2( varTexCoord.x,                 varTexCoord.y + dfbTexScale.y ) ) * dfbConvFilter[7]\
+                    + texture2D(dfbSampler, vec2( varTexCoord.x + dfbTexScale.x, varTexCoord.y + dfbTexScale.y ) ) * dfbConvFilter[8])\
+\
+                   * dfbConvFilter[9] + vec4( dfbConvFilter[10], dfbConvFilter[10], dfbConvFilter[10], dfbConvFilter[10] );\
+     }\
+     else {\
+          sample = texture2D(dfbSampler, varTexCoord);\
+     }\
+\
+     gl_FragColor = sample; \
+}";
+
+
+/*
+ * Sample texture.
  */
 static const char *blit_frag_src = " \
 uniform sampler2D    dfbSampler; \
-varying "LOWP" vec2  varTexCoord; \
+varying "MEDIUMP" vec2  varTexCoord; \
 void main (void) \
 { \
      gl_FragColor = texture2D(dfbSampler, varTexCoord); \
@@ -144,8 +197,8 @@ void main (void) \
  */
 static const char *blit_color_frag_src = " \
 uniform sampler2D    dfbSampler; \
-uniform "LOWP" vec4  dfbColor; \
-varying "LOWP" vec2  varTexCoord; \
+uniform "MEDIUMP" vec4  dfbColor; \
+varying "MEDIUMP" vec2  varTexCoord; \
 void main (void) \
 { \
      gl_FragColor = texture2D(dfbSampler, varTexCoord) * dfbColor; \
@@ -157,9 +210,9 @@ void main (void) \
  */
 static const char *blit_colorkey_frag_src = " \
 uniform sampler2D dfbSampler; \
-uniform "LOWP" vec4   dfbColor; \
+uniform "MEDIUMP" vec4   dfbColor; \
 uniform        ivec3  dfbColorkey; \
-varying "LOWP" vec2   varTexCoord; \
+varying "MEDIUMP" vec2   varTexCoord; \
 void main (void) \
 { \
      "HIGHP" vec4 value = texture2D(dfbSampler, varTexCoord); \
@@ -180,8 +233,8 @@ void main (void) \
  */
 static const char *blit_premultiply_frag_src = " \
 uniform sampler2D    dfbSampler; \
-uniform "LOWP" vec4  dfbColor; \
-varying "LOWP" vec2  varTexCoord; \
+uniform "MEDIUMP" vec4  dfbColor; \
+varying "MEDIUMP" vec2  varTexCoord; \
 void main (void) \
 { \
      gl_FragColor = texture2D(dfbSampler, varTexCoord); \
